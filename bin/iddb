#!/usr/bin/env python3
"""query idcp StructuredData parameters from xmlrpc server."""

# Copyright 2022 Helmholtz-Zentrum Berlin f√ºr Materialien und Energie GmbH
# <https://www.helmholtz-berlin.de>
#
# Author: Goetz Pfeiffer <Goetz.Pfeiffer@helmholtz-berlin.de>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.

# pylint: disable= too-many-lines, consider-using-f-string

import sys
import os
import argparse
import re
import pydoc
import configparser

import socket
import http

import xmlrpc
import xmlrpc.client

import pprint
import importlib

# pylint: disable=invalid-name

# -----------------------------------------------
# global variables

_pyver= (sys.version_info[0], sys.version_info[1])

if _pyver <= (3,4):
    HTTPEXCEPTION= http.client.HTTPException
else:
    HTTPEXCEPTION= http.client.RemoteDisconnected

DBNAME="id_db"

# environment variable IDDB_SOURCE:
#   server:gwc1c.acc.bessy.de:7643
#   file:/opt/OPI/idcp/id_db.SDCyml
ENV_VAR_NAME="IDDB_SOURCE"

#HOST="gwc1c.acc.bessy.de"
#PORT=7643

TIMEOUT=5.0 # timeout for XMLRPC

DEFAULT_COLUMNS= ["name", "devicename","key","prefix","application",
                  "group","status"]
EXTRA_COLUMNS= ["ioc", "console"]
COLUMNS= set(DEFAULT_COLUMNS+EXTRA_COLUMNS)

DEFAULT_COLUMNS_STR= " ".join(DEFAULT_COLUMNS)
COLUMNS_STR= " ".join(sorted(COLUMNS))

# -----------------------------------------------
# read configuration file

BII_SCRIPTS_CONFIG= os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                 "bii_scripts.config")

CONFIG_FILE= "iddb.config"

rx_def=re.compile(r'([^=]+)=(.*)')
rx_comment=re.compile(r'^\s*#')

def read_config(filename):
    """read config file."""
    if not os.path.exists(filename):
        raise IOError("Error, file %s not found" % filename)
    result= {}
    with open(filename) as fp: # pylint: disable= unspecified-encoding
        for line in fp:
            line= line.strip()
            if rx_comment.match(line):
                continue
            m= rx_def.match(line)
            if not m:
                continue
            name= m.group(1)
            val= m.group(2).strip()
            val= os.path.expandvars(val)
            result[name]= val
    return result

def read_biiscripts_config():
    """read bii_scripts.config."""
    if not os.path.exists(BII_SCRIPTS_CONFIG):
        sys.stderr.write("Warning: File %s not found\n" % BII_SCRIPTS_CONFIG)
        return {}
    return read_config(BII_SCRIPTS_CONFIG)

def get_share_dir():
    """get SHARE_INSTALL_DIR."""
    d= read_biiscripts_config()
    if not d:
        return None
    return d["SHARE_INSTALL_DIR"]

# -----------------------------------------------
# read iddb config file

def iddb_config():
    """read iddb configuration."""
    share_dir= get_share_dir()
    if not share_dir:
        return None
    filename= os.path.join(share_dir, "bii_scripts", CONFIG_FILE)
    if not os.path.exists(filename):
        sys.stderr.write("Warning: File '%s' not found\n" % filename)
        return None
    config = configparser.ConfigParser()
    config.read(filename)
    return config

# -----------------------------------------------
# find sourcespec from hostname

def sourcespec_by_hostname():
    """get sourcespec by current hostname."""
    def cget(config,section,key):
        """read something from configuration data."""
        if key not in config[section]:
            return None
        v= config[section][key].strip()
        if not v:
            return None
        return v
    # get configuration data from SHARE_INSTALL_DIR/bii_scripts/iddb.config:
    config_data= iddb_config()
    if not config_data:
        return None
    # get full qualified hostname:
    fullhostname= socket.getfqdn()
    # try to find it in the "HOSTS" section of the configuration:
    if "HOSTS" in config_data:
        spec= cget(config_data, "HOSTS", fullhostname)
        if spec:
            return spec
    # examine the domain:
    if "DOMAINS" in config_data:
        domain= fullhostname
        while "." in domain:
            domain= domain.split(".", 1)[1]
            spec= cget(config_data, "DOMAINS", domain)
            if spec:
                return spec
    # finally examine if there is a default "*" in HOSTS section:
    if "HOSTS" in config_data:
        spec= cget(config_data, "HOSTS", "*")
        if spec:
            return spec
    return None

# -----------------------------------------------
# parse server specification

def parse_server(spec):
    """parse a server-spec.

    returns:
        (host, port)  # port: an integer
    raises ValueError on error.
    """
    errmsg= "%s has not the form 'HOST:PORT'" % spec
    l= spec.split(":")
    if not l:
        raise ValueError(errmsg)
    if len(l)!=2:
        raise ValueError(errmsg)
    try:
        l[1]= int(l[1])
    except ValueError as e:
        raise ValueError(errmsg) from e
    return l

def parse_spec(spec):
    """parse source spec.

    spec: source specification, one of:
              server:HOST:PORT
              file:FILENAME

    returns one of:
      { "host": HOST, "port": PORT}
      { "filename": FILENAME}

    or raises a ValueError exception
    """
    l= spec.split(":", 1)
    while True:
        if not l:
            break
        if l[0] == "server":
            try:
                (host, port)= parse_server(l[1])
                return {"host": host, "port": port }
            except ValueError:
                break
        if l[0] == "file":
            if len(l)==2:
                return { "filename": l[1] }
            break
        break
    raise ValueError("Error, cannot parse source spec '%s'" % spec)

def parse_env():
    """parse environment variable IDDB_SOURCE.

    returns one of:
      { "host": HOST, "port": PORT}
      { "filename": FILENAME}
      None
    """
    var= os.environ.get(ENV_VAR_NAME)
    if var is None:
        return None
    try:
        return parse_spec(var)
    except ValueError as e:
        st= str(e).replace("Error", "Warning")
        sys.stderr.write(st)
    return None

# -----------------------------------------------
# Database access by file loading and StructuredData libraries

class DbFile:
    """Database access via StructuredData modules and file loading."""
    def __init__(self, filename):
        """initialize."""
        # import StructuredData modules locally:
        try:
            self.SD= importlib.import_module("StructuredData.Classes")
            self.fun= importlib.import_module("StructuredData.SDshelllibFun")
            self.txt= importlib.import_module("StructuredData.SDshelllibTxt")
        # Note: from python 3.6 on, we actually get a ModuleNotFoundError
        # exception here, but since this is a child class of ImportError, the
        # code here still works. Aside from this, changing ImportError to
        # ModuleNotFoundError would break compatibility with older python
        # versions.
        except ImportError:
            sys.exit("Error: Couldn't load the StructuredData python "
                     "modules. These must be available when you use this "
                     "program with option '-f'.")
        # Load the file into a StructuredDataContainer:
        self.SDC= self.SD.StructuredDataContainer.from_yaml_file(filename)
    def db_find(self,pattern,paths=""):
        """execute StructuredData "find" command."""
        return self.fun.find(pattern,False,paths,self.SDC)
    def db_txt_find(self,pattern,paths=""):
        """execute StructuredData "txt.find" command."""
        return self.txt.find(pattern,"aligned",paths,self.SDC)
    def db_txt_rxfind(self,pattern,paths=""):
        """execute StructuredData "txt.rxfind" command."""
        return self.txt.rxfind(pattern,"aligned",paths,self.SDC)
    def db_paths(self,pattern,paths=""):
        """execute StructuredData "paths" command."""
        return self.fun.paths(pattern,paths,self.SDC)
    def db_get(self,pattern,paths=""):
        """execute StructuredData "get" command."""
        return self.fun.get(pattern,False,paths,self.SDC)

# -----------------------------------------------
# Database access by XMLRPC function calls

class DbXML:
    """Database access via XMLRPC."""
    def errmsg(self, msg):
        """create a nice error message."""
        if not msg:
            return self.CONNECT_ERRMSG
        return "%s (%s)" % (self.CONNECT_ERRMSG, msg)
    def __init__(self, host, port):
        """initialize."""
        socket.setdefaulttimeout(TIMEOUT)
        self.URL='http://%s:%d' % (host, port)
        self.CONNECT_ERRMSG="Error: cannot connect to "+self.URL
        # this only creates the object, it does not actually connect:
        self.XML_OBJ = xmlrpc.client.ServerProxy(self.URL)
    def db_find(self,pattern,paths=""):
        """execute StructuredData "find" command."""
        try:
            return self.XML_OBJ.fun.find(pattern,False,paths,DBNAME)
        except (http.client.RemoteDisconnected,
                socket.gaierror, socket.timeout) as e:
            sys.exit(self.errmsg(str(e)))
    def db_txt_find(self,pattern,paths=""):
        """execute StructuredData "txt.find" command."""
        try:
            return self.XML_OBJ.txt.find(pattern,"aligned",paths,DBNAME)
        except (http.client.RemoteDisconnected,
                socket.gaierror, socket.timeout) as e:
            sys.exit(self.errmsg(str(e)))
    def db_txt_rxfind(self,pattern,paths=""):
        """execute StructuredData "txt.rxfind" command."""
        try:
            return self.XML_OBJ.txt.rxfind(pattern,"aligned",paths,DBNAME)
        except (http.client.RemoteDisconnected,
                socket.gaierror, socket.timeout) as e:
            sys.exit(self.errmsg(str(e)))
    def db_paths(self,pattern,paths=""):
        """execute StructuredData "paths" command."""
        try:
            return self.XML_OBJ.fun.paths(pattern,paths,DBNAME)
        except (http.client.RemoteDisconnected,
                socket.gaierror, socket.timeout) as e:
            sys.exit(self.errmsg(str(e)))
    def db_get(self,pattern,paths=""):
        """execute StructuredData "get" command."""
        try:
            return self.XML_OBJ.fun.get(pattern,False,paths,DBNAME)
        except (HTTPEXCEPTION,
                socket.gaierror, socket.timeout) as e:
            sys.exit(self.errmsg(str(e)))
        except xmlrpc.client.Fault as e:
            if "cannot marshal None" in str(e):
                # XMLRPC returned None
                # Note: Using "allow_none= True" in
                # xmlrpc.client.ServerProxy(self.URL) doesn't seem to avoid
                # raising the xmlrpc.client.Fault exception, so we have to
                # handle this in a bit more complicated way.
                return None
            raise

# -----------------------------------------------
# small structureddata emulation (sde)

# It is just nicer to have proper handling of StructuredData paths this way.
# In principle, x.split(".") and ".".join(l) would do...

_sde_re_escaped_wc= re.compile(r'\\+(\*|\*\*|#)$')

def sde_unescape_in_stringkey(st):
    r"""unescape special characters.

    replace '\.' with '.' and '\[number\]' with '[number]'
    This is needed in order to convert keylist to a path which
    contains the characters '.' or '[' or ']'.
    """
    if st== r"\*" : # related to class SpecialKey
        return "*"
    if st== r"\**": # related to class SpecialKey
        return "**"
    if st== r"\#" : # related to class SpecialKey
        return "#"
    if st.startswith("\\"): # starts already with a backslash
        if _sde_re_escaped_wc.match(st) is not None:
            return st[1:]
    st= st.replace(r"\.",".")
    st= st.replace(r"\[","[")
    st= st.replace(r"\]","]")
    return st

def sde_escape_in_stringkey(st):
    r"""escape special characters with a backslash.

    replace '.' with '\.' and '[number]' with '\[number\]'
    This is needed in order to convert path which contains
    the characters '.' or '[' or ']' to a keylist.
    """
    if st=="*" : # related to class SpecialKey
        return r"\*"
    if st=="**": # related to class SpecialKey
        return r"\**"
    if st=="#" : # related to class SpecialKey
        return r"\#"
    if st.startswith("\\"): # starts already with a backslash
        if _sde_re_escaped_wc.match(st) is not None:
            return "\\" + st
    st= st.replace(".", r"\.")
    st= st.replace("[", r"\[")
    st= st.replace("]", r"\]")
    return st

_sde_re_br= re.compile(r'(?<!\\)(\[)')
_sde_re_split= re.compile(r'(?<!\\)\.')
_sde_re_no= re.compile(r'\[(\d+)\]')

def sde_string_to_keyobject(val):
    """convert a wildcard to be used by the MatchPaths object.
    """
    if isinstance(val, str):
        return sde_unescape_in_stringkey(val)
    return val

def _sde_keyconvert(key_, include_separator=False):
    """convert a single key_."""
    if include_separator:
        separator= "."
    else:
        separator= ""
    if isinstance(key_, tuple):
        extra= key_[1]
        key_= key_[0]
    else:
        extra= ""
    if isinstance(key_, str):
        key_= sde_escape_in_stringkey(key_)
    elif isinstance(key_, int):
        separator= ""
        key_= "[%d]" % key_
    else:
        key_= str(key_)
    return "".join((separator,key_,extra))

def sde_path_split(path):
    """simple split of StructuredData path.

    Caution: NO support for wildcards in paths !
    """
    if not path: # empty string or None
        return []
    path= _sde_re_br.sub(r".\1", path)
    lst= _sde_re_split.split(path)
    res= []
    for elm in lst:
        m= _sde_re_no.match(elm)
        if m is not None:
            elm= int(m.group(1))
        else:
            elm= sde_string_to_keyobject(elm)
        res.append(elm)
    return res

def sde_join_path(keylist):
    r"""joins a path from a keylist.

    This method joins a list of keys to a path.  It doesn't need access to
    the StructuredDataStore so it is a static method. Usually each key of
    the keylist is a SpecialKey object, a string or an integer or a pair.
    In the latter case the pair consists of a SpecialKey, a string or an
    integer and an extra string. All these are combined to form a
    StructuredData path.
    """
    path= ".".join([_sde_keyconvert(x) for x in keylist])
    # avoid things like "A.[3]B":
    return path.replace(".[","[")

# -----------------------------------------------
# basic query functions

class Query:
    """do all queries, implement also a query cache."""
    def __init__(self, dbobj):
        """initialize."""
        self.dbobj= dbobj
        self._id_sd_keys= set()
        self._id_names= {}
        self._id_global= {}
        self._id_network= {}
        self._id_all= {}
        self._id_aliases= {}
    def sd_key_set(self):
        """return set of id keys in the StructuredData database."""
        if not self._id_sd_keys:
            for p in self.dbobj.db_paths("id-data.*"):
                self._id_sd_keys.add(sde_path_split(p)[1])
        return self._id_sd_keys
    def id_names(self, sd_key= None):
        """return a dict with id_names properties."""
        if not self._id_names:
            for my_sd_key in self.sd_key_set():
                self._id_names[my_sd_key]= \
                    self.dbobj.db_get(sde_join_path(("id-data", my_sd_key,
                                                     "names")))
        if not sd_key:
            return self._id_names
        return self._id_names[sd_key]
    def id_global(self,sd_key= None):
        """return a dict with id_global properties."""
        if not self._id_global:
            for my_sd_key in self.sd_key_set():
                self._id_global[my_sd_key]= \
                    self.dbobj.db_get(sde_join_path(("id-data",
                                                     my_sd_key,
                                                     "global")))
        if not sd_key:
            return self._id_global
        return self._id_global[sd_key]
    def id_network(self,sd_key= None):
        """return a dict with id_network properties."""
        if not self._id_network:
            for my_sd_key in self.sd_key_set():
                self._id_network[my_sd_key]= \
                    self.dbobj.db_get(sde_join_path(("id-data",
                                                     my_sd_key,
                                                     "network")))
        if not sd_key:
            return self._id_network
        return self._id_network[sd_key]
    def id_all(self,sd_key):
        """return all data for an insertion device."""
        d= self._id_all.get(sd_key)
        if not d:
            d= self.dbobj.db_get(sde_join_path(("id-data",sd_key)))
            self._id_all[sd_key]= d
        return d
    def _get_aliases(self):
        """get alias names for ids."""
        def add_alias(alias, key_):
            """add alias."""
            self._id_aliases[alias]= key_
            self._id_aliases[alias.lower()]= key_
        if not self._id_aliases:
            for sd_key, names in self.id_names().items():
                add_alias(sd_key, sd_key)
                for n in names.values():
                    if isinstance(n, int):
                        add_alias(str(n), sd_key)
                        continue
                    add_alias(n, sd_key)
                    if "/" in n:
                        add_alias(n.replace("/","-"), sd_key)
        return self._id_aliases
    def find_sd_key(self,name):
        """find sd_key from a given name."""
        return self._get_aliases()[name]
    def devicename(self,name):
        """find devicename from a given name."""
        sd_key= self.find_sd_key(name)
        return self.id_names(sd_key)["devicename"]
    def key(self,name, must_exist= True, default= None):
        """find key."""
        sd_key= self.find_sd_key(name)
        if must_exist:
            return self.id_names(sd_key)["key"]
        return self.id_names(sd_key).get("key", default)
    def prefix(self,name, must_exist= True, default= None):
        """find prefix."""
        sd_key= self.find_sd_key(name)
        if must_exist:
            return self.id_names(sd_key)["prefix"]
        return self.id_names(sd_key).get("prefix", default)
    def application(self,name, must_exist= True, default= None):
        """find application."""
        sd_key= self.find_sd_key(name)
        if must_exist:
            return self.id_global(sd_key)["application"]
        return self.id_global(sd_key).get("application", default)
    def status(self, name, must_exist= True, default= None):
        """find status."""
        sd_key= self.find_sd_key(name)
        if must_exist:
            return self.id_global(sd_key)["device_status"]
        return self.id_global(sd_key).get("device_status", default)
    def group(self,name, must_exist= True, default= None):
        """find status."""
        sd_key= self.find_sd_key(name)
        if must_exist:
            return self.id_global(sd_key)["rsync_dist_group"]
        return self.id_global(sd_key).get("rsync_dist_group", default)
    def ioc(self,name, must_exist= True, default= None):
        """find ioc name."""
        sd_key= self.find_sd_key(name)
        if must_exist:
            return self.id_network(sd_key)["ioc"]
        # Insertion devices not controlled by the idcp application do not have
        # "network" parameters, so self.id_network(sd_key) may be None:
        nw= self.id_network(sd_key)
        if nw is None:
            return default
        return self.id_network(sd_key).get("ioc", default)
    def console(self,name, must_exist= True, default= None):
        """find console name."""
        ioc= self.ioc(name, must_exist, default)
        if ioc is None:
            return ioc
        if ioc==default:
            return ioc
        return ioc.split(".",1)[0]

# -----------------------------------------------
# console I/O

def console_print_list(lst):
    """simple list printer."""
    l= sorted(lst)
    print(" ".join([str(elm) for elm in l]))

def console_print_table(table, heading=None):
    """print a table, auto-format columns."""
    widths= {}
    formats= {}
    if heading:
        for i, h in enumerate(heading):
            widths[i]= len(h)
    for line in table:
        for i, col in enumerate(line):
            if isinstance(col, int):
                col= str(col)
                if i not in formats:
                    formats[i]= "%%%dd"
            else:
                if i not in formats:
                    formats[i]= "%%-%ds"
            sz= len(col)
            old= widths.get(i, 0)
            if sz>old:
                widths[i]= sz
    sorted_widths_keys= sorted(widths.keys())
    f= " ".join([formats[i] % widths[i] for i in sorted_widths_keys])
    if heading:
        hf= " ".join(["%%-%ds" % widths[i] for i in sorted_widths_keys])
        print(hf % tuple(heading))
        l= 0
        for w in widths.values():
            l+= w
        l+= len(widths)
        print("-" * l)
    for line in table:
        print(f % tuple(line))

# -----------------------------------------------
# commands

def cmd_list(query_obj, args, rest):
    """perform list command."""
    # pylint: disable=too-many-locals, too-many-branches, too-many-statements
    print_columns= DEFAULT_COLUMNS
    if rest:
        print_columns= []
        for r in rest:
            f= r.lower()
            if f in COLUMNS:
                print_columns.append(f)
            else:
                sys.exit("error: unknown format or option "+repr(r))

    search_columns= set(print_columns)

    rx_name= None
    if args.name:
        rx_name= re.compile(args.name)
        search_columns.add("name")

    rx_application= None
    if args.application:
        rx_application= re.compile(args.application)
        search_columns.add("application")

    rx_group= None
    if args.group:
        rx_group= re.compile(args.group)
        search_columns.add("group")

    rx_status= None
    if args.status:
        rx_status= re.compile(args.status)
        search_columns.add("status")

    sort_column= print_columns[0]
    if args.sort_by:
        if not args.sort_by in COLUMNS:
            sys.exit("error: unknown column")
        if not args.sort_by in print_columns:
            sys.exit("error: sort column not in printed columns")
        sort_column= args.sort_by

    if not args.id:
        sd_keys= query_obj.sd_key_set()
    else:
        sd_keys= [query_obj.find_sd_key(args.id)]

    result= {}
    idx=0
    for sd_key in sd_keys:
        n= result.setdefault(sd_key, {})
        idx+= 1
        n["idx"]= idx # an extra index used for sorting
        for col in search_columns:
            if col=="name":
                n[col]= sd_key
                if rx_name:
                    if not rx_name.match(sd_key):
                        # must skip this entry
                        n["SKIP"]= True
            elif col=="key":
                n[col]= query_obj.key(sd_key, must_exist= False, default=0)
            elif col=="prefix":
                n[col]= query_obj.prefix(sd_key, must_exist= False, default="")
            elif col=="devicename":
                n[col]= query_obj.devicename(sd_key)
            elif col=="application":
                n[col]= query_obj.application(sd_key, must_exist= False,
                                              default="")
                if rx_application:
                    if not rx_application.match(n[col]):
                        # must skip this entry
                        n["SKIP"]= True
            elif col=="status":
                n[col]= query_obj.status(sd_key, must_exist= False,
                                         default="")
                if rx_status:
                    if not rx_status.match(n[col]):
                        # must skip this entry
                        n["SKIP"]= True
            elif col=="group":
                n[col]= query_obj.group(sd_key, must_exist= False, default="")
                if rx_group:
                    if not rx_group.match(n[col]):
                        # must skip this entry
                        n["SKIP"]= True
            elif col=="ioc":
                n[col]= query_obj.ioc(sd_key, must_exist= False, default="")
            elif col=="console":
                n[col]= query_obj.console(sd_key, must_exist= False,
                                          default="")
            else:
                raise AssertionError("internal error")

    # calc sort keys:
    # pylint: disable=consider-using-dict-items
    for k in result:
        sk= result[k][sort_column]
        if sk==0:
            sk= result[k]["idx"]/1000.0
        elif isinstance(sk, str):
            sk= "%s.%6d" % (sk, result[k]["idx"])
        result[k]["sk"]= sk

    table= []
    for k in sorted(result.keys(), key=lambda k: result[k]["sk"]):
        r= result[k]
        if r.get("SKIP"):
            continue
        line= []
        for col in print_columns:
            line.append(r[col])
        table.append(line)

    if not table:
        print("no match")
        return

    if args.no_heading:
        heading= None
    else:
        heading= print_columns
    console_print_table(table, heading)

def cmd_paths(db_obj, dbquery, args, rest):
    """perform "paths" command."""
    if not rest:
        pattern="*"
    else:
        pattern= rest[0]
    paths=""
    if len(rest)>1:
        paths= rest[1:]
    if args.id:
        id_key= dbquery.find_sd_key(args.id)
        pattern= "id-data.%s.%s" % (id_key, pattern)
    print("\n".join(db_obj.db_paths(pattern, paths)))

def cmd_find(db_obj, dbquery, args, rest):
    """perform "find" command."""
    if not rest:
        pattern="*"
    else:
        pattern= rest[0]
    paths=""
    if len(rest)>1:
        paths= rest[1:]
    if args.id:
        id_key= dbquery.find_sd_key(args.id)
        pattern= "id-data.%s.%s" % (id_key, pattern)

    #for elm in db_find(pattern, paths):
    #    print("%s %s" % (elm[0], elm[1]))
    print(db_obj.db_txt_find(pattern, paths))
    #print("\n".join(db_txt_find(pattern, paths)))
    #console_print_table(t, heading=None)

def cmd_rxfind(db_obj, dbquery, args, rest):
    """perform "rxfind" command."""
    if not rest:
        pattern=".*"
    else:
        pattern= rest[0]
    paths=""
    if len(rest)>1:
        paths= rest[1:]
    if args.id:
        id_key= dbquery.find_sd_key(args.id)
        pattern= r"id-data\.%s\.%s" % (id_key, pattern)

    print(db_obj.db_txt_rxfind(pattern, paths))
    #print("\n".join(db_txt_rxfind(pattern, paths)))
    #console_print_table(t, heading=None)

def cmd_get(db_obj, dbquery, args, rest):
    """perform "find" command."""
    if not rest:
        pattern="*"
    else:
        pattern= rest[0]
    paths=""
    if len(rest)>1:
        paths= rest[1:]
    if args.id:
        id_key= dbquery.find_sd_key(args.id)
        pattern= "id-data.%s.%s" % (id_key, pattern)
    if args.raw:
        print(db_obj.db_get(pattern, paths))
    else:
        pprint.pprint(db_obj.db_get(pattern, paths))

# -----------------------------------------------
# main program

def process(args, rest, parser):
    """do all the work.
    """
    #print("args:",args)
    #print("rest:",rest)
    # pylint: disable= global-statement, too-many-return-statements
    # pylint: disable= too-many-branches, too-many-statements
    # pylint: disable= too-many-locals
    if args.summary:
        print_summary()
        sys.exit(0)
    if args.help:
        helptext= parser.format_help()
        pydoc.pager(helptext)
        sys.exit(0)

    source_spec= None

    if args.file:
        source_spec= {"filename": args.file }
    if args.server:
        if args.file:
            sys.exit("contradicting options: -f --server")
        try:
            (host, port)= parse_server(args.server)
        except ValueError as e:
            sys.exit(str(e)+" (option --server)")
        source_spec= { "host": host, "port": port }

    # Try to parse data source from environment variable. parse_env() may
    # return None:
    if not source_spec:
        source_spec= parse_env()

    if not source_spec:
        # reads iddb configuration file:
        sp= sourcespec_by_hostname()
        if sp:
            try:
                source_spec= parse_spec(sp)
            except ValueError as e:
                sys.exit(str(e)+" (configuration file)")

    if not source_spec:
        sys.exit(("Error, no source specified.\n"
                  "You must either:\n"
                  "- set environment variable '%s'\n"
                  "- provide a StructuredData file with option '-f'\n"
                  "- provide a server with option --server\n"
                  "- define %s in file:\n"
                  "  %s") % \
                 (ENV_VAR_NAME, ENV_VAR_NAME, CONFIG_FILE))

    dbobj= None
    if "filename" in source_spec:
        dbobj= DbFile(source_spec["filename"])
    elif "host" in source_spec:
        dbobj= DbXML(source_spec["host"], source_spec["port"])
    else:
        raise AssertionError("unexpected sourcespec: %s" % repr(source_spec))

    dbquery= Query(dbobj)

    if not rest:
        cmd_list(dbquery, args, rest[1:])
        return
    if rest[0]== "list":
        cmd_list(dbquery, args, rest[1:])
        return
    if rest[0]== "name":
        l= []
        for n in rest[1:]:
            l.append(dbquery.find_sd_key(n))
        print(" ".join(l))
        return
    if rest[0]== "devicename":
        l= []
        for n in rest[1:]:
            l.append(dbquery.devicename(n))
        print(" ".join(l))
        return
    if rest[0]== "prefix":
        l= []
        for n in rest[1:]:
            l.append(dbquery.prefix(n))
        print(" ".join(l))
        return
    if rest[0] in ("ioc", "console"):
        result= []
        for n in rest[1:]:
            sd_key= dbquery.find_sd_key(n)
            if rest[0]=="console":
                result.append((sd_key, dbquery.console(sd_key)))
            else:
                result.append((sd_key, dbquery.ioc(sd_key)))
        if len(result)==1:
            print(result[0][1])
        else:
            console_print_table(result, ("name", rest[0]))
        return
    if rest[0]== "dump":
        d={}
        for n in rest[1:]:
            sd_key= dbquery.find_sd_key(n)
            d[sd_key]= dbquery.id_all(sd_key)
        pprint.pprint(d)
        return
    if rest[0]== "paths":
        cmd_paths(dbobj, dbquery, args, rest[1:])
        return
    if rest[0]== "find":
        cmd_find(dbobj, dbquery, args, rest[1:])
        return
    if rest[0]== "rxfind":
        cmd_rxfind(dbobj, dbquery, args, rest[1:])
        return
    if rest[0]== "get":
        cmd_get(dbobj, dbquery, args, rest[1:])
        return
    try:
        k= dbquery.find_sd_key(rest[0])
    except KeyError:
        sys.exit("unknown command: %s" % rest[0])
    args.id= k
    cmd_list(dbquery, args, rest[1:])

VERSION= "1.0"

SUMMARY="Show insertion device properties by querying the "+\
        "StructuredData database."

USAGE= "%(prog)s [options] command"

DESC= '''
Show insertion device properties by querying the StructuredData database.

If no command is given, the program performs the "list" command.

Commands
--------

Commands for undulator properties
+++++++++++++++++++++++++++++++++

    name NAME [NAME ...]
        Get the StructuredData name for the given insertion device. NAME may be
        any common name that specifes an insertion device like: U49ID4R u49id4r
        U49-1:Bii7 u49-1:bii7 7 U49-1 u49-1 U49/1 u49/1 idcp7
    devicename NAME [NAME ...]
        Get the devicename for the given insertion device. NAME may be any
        common name that specifes an insertion device like:
        U49ID4R u49id4r U49-1:Bii7 u49-1:bii7 7 U49-1 u49-1 U49/1 u49/1 idcp7
    prefix NAME [NAME ...]
        Show the prefix ("idcpNN") for the given insertion device. NAME is
        the same as for command "devicename" above.
    console NAME [NAME ...]
        Show the console name for the given insertion device(s). For a single
        NAME, just print the console name, for more than one NAME print results
        in a table.
    ioc NAME [NAME ...]
        Show the ioc name for the given insertion device(s). For a single
        NAME, just print the console name, for more than one NAME print results
        in a table.
    dump NAME [NAME ...]
        Print the StructuredData database for the given insertion device in
        python pretty-print format.
    list [COLUMN [COLUMN...]]
        List properties for all insertion devices. If no COLUMN is specified,
        return the following columns in this order:
            %(def_columns)s.
        If columns are specified, only show these in the given order.
        The list of all *available* columns is:
            %(all_columns)s
        Unless option --sort-by is used, sort the results by the first column.

Commands for raw StructuredData access
++++++++++++++++++++++++++++++++++++++

Note: most options except "--id" are ignore for these commands.

Note: Option -i IDNAME causes "id_data.NAME." to be prepended to PATTERN, where
      "NAME" is the StructuredData undulator name

    paths PATTERN [PATHS]
        Execute StructuredData "paths" command.
        Example: iddb --id ue112 paths 'names.*'
    find PATTERN [PATHS]
        Execute StructuredData "find" command.
        Example: iddb --id ue112 find 'names.*'
    rxfind PATTERN [PATHS]
        Execute StructuredData "rxfind" command. PATTERN is a regular
        expression here. Usually your pattern should start with '.*'.
        Example: iddb --id ue112 find '.*device'
    get PATTERN [PATHS]
        Execute StructuredData "get" command.
        Example: iddb --id ue112 get 'names.*'

Specification of the data source
--------------------------------

The data source is specified by order of precedence by these methods:

    - options '-f' or '--server'
    - environment variable 'IDDB_SOURCE'
    - configuration file $SHARE_INSTALL_DIR/bii_scripts/iddb.config

Environment variable 'IDDB_SOURCE'
++++++++++++++++++++++++++++++++++

    One of the strings:
        - server:HOST:PORT
        - file:FILENAME

Configuration file
++++++++++++++++++

The configuration file is located at $SHARE_INSTALL_DIR/bii_scripts/iddb.config.
$SHARE_INSTALL_DIR is the location of the 'share' directory.

This is a file in windows-ini format. Source specifications have that same
format as for the environment variable 'IDDB_SOURCE' (see above).

Section [HOSTS] contains source specifications specific host names,
    '*' is a default for all hosts.
Section [DOMAINS] contains source specifications specific domains. Partial
    matches of domains are supported, e.g. 'mycompany.com' matches
    'subnet1.mycompany.com'

Further documentation
---------------------

StructuredData paths in general are described here:
    https://yaml-structureddata.sourceforge.io/reference.html#paths

The Insertion device database is described here:
    http://wiki.trs.bessy.de/bin/view/Controls/IdcpDb

''' % {"all_columns": COLUMNS_STR, "def_columns": DEFAULT_COLUMNS_STR}

def script_shortname():
    """return the name of this script without a path component."""
    return os.path.basename(sys.argv[0])

def print_summary():
    """print a short summary of the scripts function."""
    print("%-20s: %s\n" % (script_shortname(), SUMMARY))


def main():
    """The main function.

    parse the command-line options and perform the command
    """
    parser = argparse.ArgumentParser(\
                 usage= USAGE,
                 description= DESC,
                 formatter_class=argparse.RawDescriptionHelpFormatter,
                 add_help= False
                                    )
    parser.add_argument('--version', action='version', version='%%(prog)s %s' % VERSION)

    parser.add_argument("--summary",
                        action="store_true",
                        help="print a summary of the function of the program",
                       )
    parser.add_argument("-h","--help",
                        action="store_true",
                        help="Print help (with pager)",
                       )

    parser.add_argument("-S", "--sort-by",
                        help="specify the SORTCOLUMN",
                        metavar="SORTCOLUMN"
                       )
    parser.add_argument("-N", "--no-heading",
                        action="store_true",
                        help="do not print a table heading",
                        )
    parser.add_argument("-n", "--name",
                        help="filter by NAME (regexp)",
                        metavar="NAME"
                       )
    parser.add_argument("-i", "--id",
                        help="filter by IDNAME. IDNAME must be "
                             "any common name that specifies the insertion "
                             "device.",
                        metavar="IDNAME"
                       )
    parser.add_argument("-a", "--application",
                        help="filter by APPLICATION (regexp)",
                        metavar="APPLICATION"
                       )
    parser.add_argument("-g", "--group",
                        help="filter by GROUP (regexp)",
                        metavar="GROUP"
                       )
    parser.add_argument("-s", "--status",
                        help="filter by STATUS (regexp)",
                        metavar="STATUS"
                       )
    parser.add_argument("--server",
                        help="specify the StructuredData XML-RPC "
                             "server in the form 'HOST:PORT'",
                        metavar="SERVER"
                       )
    parser.add_argument("-r", "--raw",
                        action="store_true",
                        help="do *not* use python pretty-print to print "
                             "data, just print the raw value."
                       )
    parser.add_argument("-f", "--file",
                        help="Load STRUCTUREDDATAFILE instead of contacting "
                             "an XMLRPC server. Note: For this the "
                             "StructuredData python modules must be "
                             "installed on your system.",
                        metavar="STRUCTUREDDATAFILE"
                       )

    (args, rest) = parser.parse_known_args()

    if args.summary:
        print_summary()
        sys.exit(0)

    process(args, rest, parser)
    sys.exit(0)

if __name__ == "__main__":
    main()
