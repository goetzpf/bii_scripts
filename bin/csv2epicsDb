#!/usr/bin/env python
"""

 *  Author  B.Kuner
	    R.Lange

  USAGE: cvs2epicsDb [OPTIONS] <csv files ...>
  
-c --can:        CAN port Nr., or 'opc' for OPC server access
-d --output_db:  db file name file ending determines the ouptut: '.db' 
    	    	 or '.substitutions'
-f --install_path: installation path for output files: .substitutions, .arch, .alh,
    	    	 panels. Default is './' 
-i --iocName:    IOC name 
-l --output_alh: create alarm handler config file for Items that define BESSY ALH 
    	    	 Group (col. Q) 
-m --opc_name:   opc server name 
-n --devName:    device name [\(DEVICE)] 
-p --panel:      create 'CreatePanel.pl' data for Items that define EPICS 
    	    	 devObj.panelName (col. T) 
-q --quiet:      be quiet
-r --output_req: autoSaveRestore request file name for signals defined in Col. P 
-s --display_search_path: for panel generation only, search path for 
    	    	 widget/header/footer files [.:..]
-t --separator:  column separator in .csv file[,] 
-v --verbose:    print debug information 
   --desc-len:   length of DESC field (dependant on EPICS version)
"""

from optparse import OptionParser
import sys
import os
import re
import math
import csv
import BDNS
import os.path
import epicsUtils
import csv2epicsFuncs

my_version = "1.0"

class docList(object):
    """
    Simple class to store and print a documentation table in makeDoc format. 
    Each object in this class contains a list of arbitrary items, to be print as table. 
    First item should be the header, if required.
    """
    dList=[]
    title = "Title"
    def __init__(self,fieldList) :
	def initField(x):
	    x = epicsUtils.substRe(str(x),'\|','&#124;')
	    if len(x)==0: x='-'
	    return x
	docList.dList.append(map(lambda x:initField(x),fieldList))
    @staticmethod
    def printDoc():
	printStr = docList.title+"\n**********\n\n"
	for line in docList.dList:
	    printStr += "|".join(line)+"\n"
	printStr = epicsUtils.substRe(printStr,"\|\|","|-|")
	return printStr+"\n"

    @staticmethod
    def setTitle(h):
    	docList.title = h

#******************************* Main program *******************************

separator    =','
output_db    = None
output_panel = None
output_alh   = None
output_arch  = None
output_req   = None
install_path = "."
display_search_path = ".:.."
iocName  = None
devName  = '(DEVICE)'
opc_name     = None
usage        = " %prog [options]"
parser = OptionParser(usage=usage,
		 version="%%prog %s" % my_version,
    		 description="USAGE: csv2epicsDb [-h OPTIONS] <csv files ...>")
parser.add_option("-a","--output_arch", 
		 action="store",
    		 type="string",
		 help="archiver config file name for signals defined n Col. O", 
    		 )
parser.add_option("-c","--can", 
		 action="store",
    		 type="string",
		 help="CAN port Nr., or 'opc' for OPC server access",
    		 )
parser.add_option("-d","--output_db", 
		 action="store",
    		 type="string",
		 help="db file name file ending determines the ouptut: '.db' or '.substitutions'",
    		 )
parser.add_option("-f","--install_path",
		 action="store",
    		 type="string",
		 help="installation path for output files: .substitutions, .arch, .alh, panels. Default is './'", 
    		 )
parser.add_option("-i","--iocName", 
		 action="store",
    		 type="string",
		 help="IOC name ",
    		 )
parser.add_option("-l","--output_alh", 
		 action="store_true",
		 help="create alarm handler config file for Items that define BESSY ALH Group (col. Q, )", 
    		 )
parser.add_option("-m","--opc_name", 
		 action="store",
    		 type="string",
		 help="opc server name", 
    		 )
parser.add_option("-n","--devName", 
		 action="store",
    		 type="string",
		 help="device name [\(DEVICE)]", 
    		 )
parser.add_option("-p","--panel",
		 action="store_true",
		 help="create 'CreatePanel.pl' data for Items that define EPICS devObj.panelName (col. T, )", 
    		 )
parser.add_option("-q","--quiet",
		 action="store_true",
		 help="be quiet", 
    		 )
parser.add_option("-r","--output_req", 
		 action="store",
    		 type="string",
		 help="autoSaveRestore request file name for signals defined in Col. P", 
    		 )
parser.add_option("-s","--display_search_path",
		 action="store",
    		 type="string",
		 help="for panel generation only, search path for widget header/footer files '.:..'", 
    		 )
parser.add_option("-t","--separator", 
		 action="store",
    		 type="string",
		 help="column separator []", 
    		 )
parser.add_option("-v","--verbose",
		 action="store_true", # default: None
		 help="print debug information", 
    		 )
parser.add_option("--desc-len",
		 action="store",
    		 type="int",
		 help="length of DESC field length of DESC field (dependant on EPICS version)",
    		 )

(options, args) = parser.parse_args()
canOption = ""
if options.separator    is not None: separator    = options.separator
if options.can   	is not None: canOption	  = options.can
if options.output_db	is not None: output_db    = options.output_db
if options.panel	is not None: output_panel = options.panel
if options.install_path	is not None: install_path = options.install_path
if options.display_search_path	is not None: display_search_path = options.display_search_path
if options.output_arch	is not None: output_arch  = options.output_arch
if options.output_req	is not None: output_req   = options.output_req
if options.iocName	is not None: iocName      = options.iocName
if options.opc_name	is not None: opc_name	  = options.opc_name
if options.desc_len	is None: options.desc_len = 28

sdis=""# options.devName+":disable CPP NMS"
iocTag = None

if iocName is not None:
    try:
    	m = epicsUtils.matchRe(iocName,"^\w*IO(C[\w\d]+$)")
	iocTag = m[0]
    except TypeError:
	pass

warnings = []	     # global for warnings in all functions, is printed at end or prog.

lines = None
table = []  	    # Debug information in verbose mode
db   = []	    # substitution file lines
arch = []	    # archive list
req = []	    # autoSaveRestore list
panelList = epicsUtils.Panels(install_path,display_search_path)

def joinItarch(): return "<group>\n<name>"+output_arch.replace(".arch","")+"</name>\n"+"\n".join(arch)+"\n</group>" 
def joinItreq():  return "\n".join(req)

if output_db is None:
    print "Missing option -d outFile.db"
    sys.exit()
else:
    output_doc = epicsUtils.substRe(output_db,"\.\w+$","Doc.txt")

if canOption == 'opc':
    docList(["Device Name","BESSY Signalname","PLC Name","Bits","Description","Typ\n----+-----"])
else:
    docList(["Device Name","BESSY Signalname","CAN-Port","CAN-Id","devObj.cardNr","Channel / Bits","Description","Typ\n----+-----"])
docList.setTitle( str(epicsUtils.matchRe(output_db,"(?:.*/|)(.*)\.\w+$")[0])+" Devices" )

types = { "db"  : [output_db, None],
          "doc":  [output_doc,docList.printDoc],
          "arch": [output_arch,joinItarch],
          "req" : [output_req, joinItreq ]}
if epicsUtils.matchRe(output_db,".*\.db$") is not None:
    types['db'][1] = epicsUtils.epicsTemplate.printAllRecords
elif epicsUtils.matchRe(output_db,".*\.substitutions$") is not None:
    types['db'][1] = epicsUtils.epicsTemplate.printAllSubst
else:
    epicsUtils.die("unknown output format for file -d '"+output_db+"'")
debugInfo = {}

for argument in args:
    if not os.path.isfile(argument): epicsUtils.die("File doesn't exist: "+argument)

    if not options.quiet:
        print "   Reading data from "+argument

    try :
    	(fileName,fileExt) = epicsUtils.matchRe(argument,'.*\/(.*)\.(.*)') 
    except TypeError : 
    	epicsUtils.die("found no filename in: "+argument)

    try :
	IN_FILE = open(argument) 
    except IOError: 
    	epicsUtils.die("can't open input file: "+argument)
    
    lines = 0
    reader = csv.reader(IN_FILE, delimiter=separator, quotechar='"',quoting=csv.QUOTE_ALL)

    for device in reader:
   	try:
	    lines += 1
	    if lines <= 1: # is header
	    	continue

	    devObj = csv2epicsFuncs.csvData(device,canOption,lines)

	    if len(devObj.rtype) == 0: # is no device
	    	continue

    	    if len(devObj.dev)>0:  	# override -n option
	    	devName = devObj.dev
	    elif options.devName is not None: 
		devName = options.devName
	    else:
	    	print "ERROR: No device name line:",lines
		sys.exit()

	    ## Check if Description exceeds the EPICS String length, truncate it and create warning
	    if len(devObj.DESC) > options.desc_len :
		lastIdx = options.desc_len
		descTrunc = devObj.DESC[0:lastIdx]
		warnings.append([fileName,lines,"Truncate devObj.DESC",devName,descTrunc+" | "+devObj.DESC])
    		devObj.DESC = descTrunc
	    alhSignals = []	    # templates may have a list of signals for alarm handler
	    arcSignals = []	    # templates may have a list of signals for archiver
    	    panelDict = {}  	    # panel widget macro data
	    panelNameDict = {}	    # panel widget PV name in form of {'TAG':pvName} dictionary
	    panelWidgetName = None

	    fields = {}
	    fields.update(epicsUtils.parseParam(devObj.prec))
    	    if devObj.rtype in ['ai','ao','longin','longout','bi','bo','mbbi','mbbo','aoOroc','calc','calcout']: 	    	# is a record
		alhSignals.append(devObj.signal)
		arcSignals.append(devObj.signal)
		fields.update({'SNAME': devObj.signal,
	    		'DISS': 'INVALID',
	    		'SDIS': sdis,
    	    		'DESC': devObj.DESC})
		if canOption == 'opc':
		    fields.update(epicsUtils.getOpcLink(devObj.port,devObj.rtype,devObj.chan,devName,opc_name,lines,fileName))
    	    	else:	# ommit parameter or canport number means CAN link
    	    	    try:
		    	fields.update(epicsUtils.getHwLink(devObj.rtype,devObj.port,devObj.canId,devObj.cardNr,devObj.chan,devName,fileName,iocTag,lines) )
		    except ValueError:
		    	warnings.append([fileName,lineNr,"WARN: ",name,"No CAN-Id/DTYP (Col. E) Can't create link"])
		try:
    		    if devObj.rtype in ('ai','ao') :
	    		csv2epicsFuncs.createAnalogRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.egu,devObj.rangeAlhVal,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
    		    elif devObj.rtype in ('longin','longout') :
	    		fields['SNAME']=devObj.signal
	    		csv2epicsFuncs.createAnalogRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.egu,devObj.rangeAlhVal,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
		    elif devObj.rtype in ('bi','bo'):
			    csv2epicsFuncs.createBiBoRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
		    elif devObj.rtype in ('mbbi','mbbo'):
    	    		    csv2epicsFuncs.createMbbIoRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
    		    elif devObj.rtype == 'aoOroc':	# treat aoOroc as ao record
	    		csv2epicsFuncs.createAnalogRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.egu,devObj.rangeAlhVal,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
			if canOption == 'opc':
			    fields.update(epicsUtils.getOpcLink(devObj.port,'ao',devObj.chan,devName,opc_name,lines,fileName))
    	    		else:	# ommit parameter or canport number means CAN link
    	    		    try:
		    		fields.update(epicsUtils.getHwLink('ao',devObj.port,devObj.canId,devObj.cardNr,devObj.chan,devName,fileName,iocTag,lines) )
			    except ValueError:
		    		warnings.append([fileName,lineNr,"WARN: ",name,"No CAN-Id/DTYP (Col. E) Can't create link"])
			epicsUtils.epicsTemplate(devObj.rtype,{'DEVN':devName},fields)
    	    	    else:
			epicsUtils.epicsTemplate(devObj.rtype, {'DEVN':devName}, fields)
		    if len(devObj.reqFlag) > 0: req.append(devName+":"+devObj.signal)

    		    if devObj.rtype in ('bo') :
			panelDict.update({'SNAME':devObj.signal,'EGU':devObj.egu,'DESC':devObj.DESC})
			panelWidgetName = "bo"
    		    elif devObj.rtype in ('ao','longout') :
			panelDict.update({'SNAME':devObj.signal,'EGU':devObj.egu,'DESC':devObj.DESC})
			panelWidgetName = "ao"
    		    elif devObj.rtype in ('mbbo') :
			panelDict.update({'SNAME':devObj.signal,'EGU':devObj.egu,'DESC':devObj.DESC})
			panelWidgetName = "mbbo"
    		    elif devObj.rtype == 'aoOroc' :
			panelDict.update({'SNAME':devObj.signal,'DESC':devObj.DESC})
			panelWidgetName = "aoOroc"
		    else:
			panelDict.update({'SNAME':devObj.signal,'EGU':devObj.egu,'DESC':devObj.DESC})
			panelWidgetName = "anyVal"
		    panelNameDict.update({'DEVN':devName})
		except ValueError:
		    continue
	    else:	    	    	    	# is a template
		if len(devObj.reqFlag) > 0: 
	    	    req += map(lambda x: devName+":"+x,devObj.reqFlag.split("|"))
		    print "REG:",devObj.reqFlag, req

		if devObj.rtype=="aiFB":
    	    	    fields.update({'INP' : '@'+devObj.port})
		    alhSignals.append(devName+":set"+fields['TAG'])
		    arcSignals.append("set"+fields['TAG'])
		    panelNameDict.update({'DEVN':devName})
		    panelDict.update({'TAG':fields['TAG'],'DESC':devObj.DESC})
		    panelWidgetName = "aiFB"
		    csv2epicsFuncs.createAnalogRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.egu,devObj.rangeAlhVal,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
		elif devObj.rtype=="longinFB":
    	    	    fields.update({'INP' : '@'+devObj.port})
    	    	    fields.update(epicsUtils.parseParam(devObj.rangeAlhVal))
		    alhSignals.append(devName+":cmd"+fields['TAG'])
		    arcSignals.append("cmd"+fields['TAG'])
		    panelNameDict.update({'DEVN':devName})
		    panelDict.update({'TAG':fields['TAG'],'DESC':devObj.DESC})
		    panelWidgetName = "aiFB"
		    csv2epicsFuncs.createAnalogRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.egu,devObj.rangeAlhVal,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
		elif devObj.rtype=="biFB":
		    fld = epicsUtils.getOpcLink(devObj.port,'bi',devObj.chan,devName,opc_name,lines,fileName)
		    fields.update(fld)
    	    	    fields.update(epicsUtils.parseParam(devObj.rangeAlhVal))
		    alhSignals.append(devName+":cmd"+fields['TAG'])
		    arcSignals.append("cmd"+fields['TAG'])
		    panelNameDict.update({'DEVN':devName})
		    panelDict.update({'TAG':fields['TAG'],'DESC':devObj.DESC})
		    panelWidgetName = "biFB"
		    csv2epicsFuncs.createBiBoRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
		elif devObj.rtype=="mbbiFB":
		    fld=epicsUtils.getOpcLink(devObj.port,'mbbi',devObj.chan,devName,opc_name,lines,fileName)
		    fields.update(fld)
    	    	    fields.update(epicsUtils.parseParam(devObj.rangeAlhVal))
		    alhSignals.append(devName+":cmd"+fields['TAG'])
		    arcSignals.append("cmd"+fields['TAG'])
		    panelNameDict.update({'DEVN':devName})
		    panelDict.update({'TAG':fields['TAG'],'DESC':devObj.DESC})
		    panelWidgetName = "biFB"
		    csv2epicsFuncs.createBiBoRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
		elif devObj.rtype=="vacuum_OPC":
    	    	    fields.update({'DESC':devObj.DESC, 'INP':'@'+devObj.port,'EGU':devObj.egu})
    	    	    fields.update(epicsUtils.parseParam(devObj.rangeAlhVal))
		    alhSignals.append(devName+":lvac")
		    arcSignals.append(fields['TAG']+":lvac")
		    arcSignals.append(fields['TAG']+":vac")
		    panelDict.update({'TAG':fields['TAG'],'DESC':devObj.DESC,'EGU':devObj.egu})
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = "vmi"
		    epicsUtils.epicsTemplate(devObj.rtype, {'DEVN':devName}, fields)
    		elif epicsUtils.matchRe(devObj.rtype,"^vacuum_\w\w\w\d\d\d$") is not None:
		    (canOut,canIn,mux) = epicsUtils.adaCanMux(devObj.canId,devObj.cardNr,devObj.chan)
		    alhSignals.append("rdPress")
		    arcSignals.append("rdPress")
		    panelNameDict.update({'NAME':devName})
		    panelWidgetName = "Vmi"
		    epicsUtils.epicsTemplate(devObj.rtype, {'NAME':devName}, {
        		'DESC': devObj.DESC,
        		'port':devObj.port,
			'OUTCAN': canOut,
			'INCAN':  canIn,
			'MUX':    mux,
			'ASG':    "",
			'SDIS':   "",})
		elif devObj.rtype=="vacuum_VarianDualController":
		    alhSignals.append("rdHighVolt")
		    alhSignals.append("rdPress")
		    arcSignals.append("rdHighVolt")
		    arcSignals.append("rdPress")
		    panelNameDict.update({'NAME':devName})
		    panelWidgetName = "Gpps"
		    (canOut,canIn,mux) = epicsUtils.adaCanMux(devObj.canId,devObj.cardNr,devObj.chan)
		    mux1 = "%X"% (int(devObj.cardNr)*12+1+int(devObj.chan),)
		    epicsUtils.epicsTemplate(devObj.rtype, {'NAME':devName}, {
        		'DESC': devObj.DESC,
        		'port':devObj.port,
			'OUTCAN': canOut,
			'INCAN':  canIn,
			'MUX':    mux,
			'MUX2':   mux1,
			'ASG':    "",
			'SDIS':   "",})
    		elif devObj.rtype=="valve_VCTRL":
		    alhSignals.append("stItlHw",)
		    arcSignals.append("stModOpen",)
		    arcSignals.append("stItlHw",)
		    panelNameDict.update({'NAME':devName})
		    panelWidgetName = "Valve"
		    canOut = "%X"%(576+int(devObj.canId),)
		    canIn  = "%X"%(512+int(devObj.canId),)
		    muxIn  = "%X"%(int(devObj.cardNr)*2,)
		    muxOut = "%X"%(int(devObj.cardNr)*2+1,)
		    epicsUtils.epicsTemplate(devObj.rtype, {'NAME':devName}, {
        		'DESC': devObj.DESC,
        		'port':devObj.port,
			'OUTCAN': canOut,
			'INCAN':  canIn,
			'MUXIN':  muxIn,
			'MUXOUT': muxOut,
			'ASG':    "",
			'ASGOPEN':    "OPEN",
			'SDIS':   "",})
		elif devObj.rtype=="aiCAN":
	    	    fields.update({'DISS': 'INVALID',
        	    	    'INP':  epicsUtils.createAdaCanLink(devObj.port,devObj.canId,devObj.cardNr,devObj.chan),
    	    	    	    'DESC': devObj.DESC})
		    alhSignals.append("rdVolt")
		    arcSignals.append("rdVolt")
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = "aiCAN"
		    csv2epicsFuncs.createAnalogRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.egu,devObj.rangeAlhVal,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
		elif devObj.rtype=="pmu":
	    	    createLimits(devObj.rangeEng,devObj.rangeRaw,devObj.rangeAlhVal,devObj.rangeAlhSevr,devName,None)
		    fields['RANGE'] = devObj.rangeEng+" "+devObj.egu
		    fields.update({'DISS': 'INVALID',
        	    	    'INP':  epicsUtils.createAdaCanLink(devObj.port,devObj.canId,devObj.cardNr,devObj.chan),
    	    	    	    'DESC': devObj.DESC})
		    alhSignals.append("rdPwr")
		    arcSignals.append("rdPwr")
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = "PMU"
		    csv2epicsFuncs.createAnalogRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.egu,devObj.rangeAlhVal,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
    		elif devObj.rtype=="pt100temp":
		    alhSignals.append("rdTemp")
		    arcSignals.append("rdTemp")
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = "temp"
		    try:
    	    		hwname = epicsUtils.getEcName(devObj.port,devObj.canId,devObj.cardNr,iocTag)
    	    	    except ValueError:
    	    		epicsUtils.die("ERROR: "+devName+" CAN definition Port=\'"+devObj.port+"\' Id: \'"+devObj.canId+"\' Card: \'"+devObj.cardNr+"\''",lines)

		    if epicsUtils.epicsTemplate.getDevice(hwname) is None:
			(co,ci,mux) = epicsUtils.adaCanMux(devObj.canId,devObj.cardNr,0,'dec')
			mux=int(devObj.cardNr)*12

			epicsUtils.epicsTemplate("pt100dev",{'DEVN':hwname},{
		    	    'port': devObj.port,
			    '0XSINOBJ':"%X"%(128+int(devObj.canId)),
			    '0XSOUTOBJ':"%X"%(192+int(devObj.canId)),
			    '0XSMUX':"%X"%(int(devObj.cardNr)*4+17),
			    'INOBJ':ci,
			    'OUTOBJ':co,
			    'C0MUX':mux,
			    'C1MUX':mux+1,
			    'C2MUX':mux+2,
			    'C3MUX':mux+3,
			    'C4MUX':mux+4,
			    'C5MUX':mux+5,
			    'C6MUX':mux+6,
			    'C7MUX':mux+7
			    })
		    if devObj.egu == "K":	    # template default is Grad-C
			fields['EGUF'] = "657.16"
			fields['EGUL'] = "145.16"
			fields['EGU'] = "K"
		    fields['DESCR'] = devObj.DESC
		    fields['SDIS']  = ""
		    fields['HWNAME']= hwname
    	    	    devObj.chan = int(devObj.chan)
		    if devObj.chan<8: 
			ch  = 1
			sub = devObj.chan
		    else:      
			ch  = 2
			sub = devObj.chan-8
		    statnr = "%X"%(devObj.chan)
		    fields['chan']  = ch
		    fields['STATNR']= statnr
		    fields['SUB']   = sub
		    csv2epicsFuncs.createAnalogRecord(devObj.rtype,devName,fields,devObj.rangeEng,devObj.rangeRaw,devObj.egu,devObj.rangeAlhVal,devObj.rangeAlhSevr,devObj.signal,fileName,lines)
    		elif devObj.rtype=="foilMonitor":
		    alhSignals.append("stPos")
		    arcSignals.append("stPos")
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = None
		    ch = devObj.chan.split("|")
		    if int(ch[0])+1 != int(ch[1]):
	    		warnings.append([fileName,lines,"WARN: ",devName,"No consecutive input parameters: "+devObj.chan+", assumed: "+str(ch[0])+"|"+str(int(ch[0])+1)])
    	    	    epicsUtils.epicsTemplate("foilMonitor",{'DEVN':devName},{
			'CARD': devObj.cardNr,
			'chan': ch[0],
			'DTYP': devObj.canId
			})
		else:
		    print "Skip unsupported record/template '"+devObj.rtype+"' Line:",lines
		    continue
    	    # END search and create record type
	    # now processing is done, an record is created and we can use the variables, set 
	    # for this line of the spread sheet to do some optional stuff
    	    if devObj.signal != "":
    		if canOption == 'opc':
	    	    docList([devName,devObj.signal,devObj.port,devObj.chan,devObj.DESC,devObj.rtype])
		else:
		    docList([devName,devObj.signal,devObj.port,devObj.canId,devObj.cardNr,devObj.chan,devObj.DESC,devObj.rtype])
	    if options.verbose is True:
		rangeRawCut = devObj.rangeRaw
		if len(devObj.rangeRaw)> 23:
		      rangeRawCut = devObj.rangeRaw[0:20] +"..."
		rangeEngCut = devObj.rangeEng
		if len(devObj.rangeEng)> 23:
		      rangeEngCut = devObj.rangeEng[0:20] +"..."
		table.append([fileName,lines,devObj.rtype,devName,link,rangeEngCut,rangeRawCut,devObj.egu,devObj.DESC])

	    if output_panel is not None and len(devObj.panelName)>0: # for panel creation
		panelList.addItem(devObj.panelName,devObj.panelGroup,panelNameDict,panelDict,panelWidgetName,devObj.panelSort)

	    if devObj.archPeriod is not None and len(devObj.archPeriod)>0:
		for devObj.signal in arcSignals:
	    	    arch.append( "<channel><name>"+devName+":"+devObj.signal+"</name><period>"+devObj.archPeriod+"</period><monitor/></channel>")

	    if devObj.alhGroup is not None and len(devObj.alhGroup)>0:
		for alhSig in alhSignals:
    		    epicsUtils.epicsAlh(devName,alhSig,devObj,lines)
    	except :
	    print "Parse exception in '"+argument+"' line:",lines
	    raise
    IN_FILE.close()
    # end for
#########################################################################
    epicsUtils.PLC_Address.setupTemplates(devName,'opc')
  # Create files
    for typ in types.keys():
      	outfile = types[typ][0]
      	strOut  = types[typ][1]()
	if outfile == None or len(strOut) == 0:
            continue
      	else:
	    try:
	    	outFileName = install_path+"/"+outfile
		OUT_FILE = open(outFileName,"w") 
	    except IOError: 
	    	epicsUtils.die("can't open output file: "+outFileName)
        if not options.quiet:
            print "   Creating file "+outFileName
      	#print "*****************************\n", strOut
	print >> OUT_FILE, strOut
	OUT_FILE.close()

    if options.output_alh is True:
	epicsUtils.epicsAlh.printFiles(install_path)
    	
    if options.verbose is True:
	epicsUtils.printTable(table,["file","line","record","devName","link","rangeEng","rangeRaw","egu","DESC"],1 ) 

  #  str  map { str += "\t_\tsoftLinkTag{_}\n" } keys(%softLinkTag) print "mbbiDiret Ids:\nstr\n"
    if (output_db is not None) and (len(warnings) > 0):
      	print "\nWARNINGS\n********\n\n"
      	epicsUtils.printTable(warnings, ["file","line","Warning","PV-Name","Value"])
      	print "\n"

    if output_panel is not None:  # for panel creation panelInfos->{recordType}->[pv1, pv2...
	panelList.printAll()
