#!/usr/bin/python
"""

 *  Author  B.Kuner
	    R.Lange

  USAGE: cvs2epicsDb [-h -v -t<char>] <csv files ...>
  
 -h: this help
 -t: column separator []
 -n: device name [\(DEVICE)]
 -p: create 'CreatePanel.pl' data for all signal service panel
 -d: db file name
 -l: alarm handler config file
 -a: archiver config file name
 -r: autoSaveRestore request file name
 -v: print debug information

"""

from optparse import OptionParser
import sys
import os
import re
import math
import csv
import BDNS
import os.path
import epicsUtils

my_version = "1.0"

class docList(object):
    """
    Simple class to store and print a documentation table in makeDoc format. 
    Each object in this class contains a list of arbitrary items, to be print as table. 
    First item should be the header, if required.
    """
    dList=[]
    title = "Title"
    def __init__(self,fieldList) :
	def initField(x):
	    x = epicsUtils.substRe(x,'\|','&#124;')
	    if len(x)==0: x='-'
	    return x
	docList.dList.append(map(lambda x:initField(x),fieldList))
    @staticmethod
    def printDoc():
	printStr = docList.title+"\n**********\n\n"
	for line in docList.dList:
	    printStr += "|".join(line)+"\n"
	printStr = epicsUtils.substRe(printStr,"\|\|","|-|")
	return printStr+"\n"

    @staticmethod
    def setTitle(h):
    	docList.title = h

def getDisplayLimits(rangeEng,egu,signal=None,lines=None):
    eng = epicsUtils.matchRe(rangeEng,"([-+\d][\d\.eE]*)\s*\-\s*([-+\d][\d\.eE]*)*")
    if eng == None or len(eng) != 2:
    	epicsUtils.die("Need range Eng. for signal "+signal,lines)
    return({'LOPR':float(eng[0]),'HOPR':float(eng[1]),'EGU':egu});
    
def createLimits(rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal=None,lines=None):
    """
    Create limits for analog type records

    - If 'rangeRaw' is defined: Create konversion parameters 
    - rangeAlhVal has to be in order with rangeAlhSevr to define alarm ranges and severities
      rangeAlhVal can be followed by arbitrary additional fields to be set for records, so the 
      rangeAlhVal fields have to be  set outside this function
    """
#    print "createLimits(rangeEng='",rangeEng,"', rangeRaw='",rangeRaw,"', rangeAlhVal='",rangeAlhVal,"', rangeAlhSevr='",rangeAlhSevr,"', signal='",signal,"')"
#    if lines is None: print "createLimits(rangeEng='",rangeEng,"', rangeRaw='",rangeRaw,"', rangeAlhVal='",rangeAlhVal,"', rangeAlhSevr='",rangeAlhSevr,"', signal='",signal,"')"

    (lopr,hopr) = epicsUtils.matchRe(rangeEng,"\s*(.*)\s*\-\s*(.*)\s*")
    lopr = float(lopr)
    hopr = float(hopr)
    dtype = ""	    # for CAN data - s=short, S=unsigned short
    field = {}
    if rangeAlhVal != "":
	aFields=epicsUtils.parseParam(rangeAlhVal)
	field.update(aFields)
	
	limitVals = rangeAlhVal.split("|")  	# ATTENTION: preserve the order of alarm and severity fields
	limitSevr = rangeAlhSevr.split("|")
	if len(limitSevr[0]) > 0:   # means not empty severities
	    for (v,s) in zip(limitVals,limitSevr):  
		(valName,val)     = v.split("=")
		if valName   == 'LOLO': field['LLSV'] = s
		elif valName == 'LOW':  field['LSV']  = s
		elif valName == 'HIGH': field['HSV']  = s
		elif valName == 'HIHI': field['HHSV'] = s
		else: epicsUtils.die("Illegal Alarm value '"+valName+"' in signal: "+signal,lines)
    
    raw = epicsUtils.matchRe(rangeRaw,"\s*(.*)\s*\-\s*(.*)\s*")
#    if lines is None: print lopr, hopr, raw
    if raw is not None:
	lraw=float(raw[0])
	hraw=float(raw[1])
	egul  = 0.0
	eguf  = 0.0
	slope = 0.0
	off   = 0.0
	hyst  = 0.0
	full  = 0.0
	minVal=0
    	convert = 'SLOPE'   # LINEAR not supported yet
	
    #  die "CAN data type is unsigned short, so only positive limits supported" if( lopr is not 0 || lraw is not 0 )

	if  (hopr != 0) and ( hraw != 0 ):
      	    if (lraw < 0) or (hraw < 0 ):         # signed value
		dtype = "s"
		full = 32767
		minVal = -32767
    	    else:                                 # unsigned
		dtype = "S"
		full = 65535
	    if convert == "LINEAR":
		egul = lopr - slope * (lraw-minVal)
		eguf = egul + slope * 65535
		field['LINR'] = 'LINEAR'
		field['EGUL'] = egul
		field['EGUF'] = eguf
	    elif convert == "SLOPE":
		slope = (hopr - lopr) / (hraw - lraw)
		off  = hopr - slope * hraw
		field['LINR'] = 'SLOPE'
		field['ESLO'] = slope
		field['EOFF'] = off
	    prec =  int(math.log(float(hopr)/10000)/math.log(10.0))
    #ORGINAL: prec = ( ( prec >= 0 ) ? 0 : -prec ) + 1
	    if prec < 0 : 
		prec = (-1 * prec)+1
	    else:
		prec = 0
	    hyst = hopr / hraw * 0.99
	    field['PREC'] = prec
	    field['HYST'] = hyst
	    field['ADEL'] = hyst
	    field['MDEL'] = hyst
	else:
      	    epicsUtils.die("Raw/engineering limit mismatch (raw: hraw / eng: hopr)",lines)
#    if lines is None: print field
    return (field,dtype)

def getBinaryAttributes(rangeEng,rangeRaw,fields,fileName,lines):

    rangeENG = []
    rangeRAW = []
    rangeALH = []
    r = rangeEng.split("|")
    if isinstance(r,list) is True and len(r)>1:
	rangeENG = map(lambda x: x.strip(),r)
	rangeLen = len(r)
	r = rangeRaw.split("|")
	if isinstance(r,list) is True and len(r) == rangeLen:
	    rangeRAW = map(lambda x: x.strip(),r)
	else:
	    warnings.append([fileName,lines,"Skip: ",devName,"Illegal rangeRaw (Col: I): \'"+rangeRaw+"\'"])
	    raise ValueError
	r = rangeAlhSevr.split("|")
	if isinstance(r,list) is True and r[0] != '':	# No alarms is ok, but..
	    if len(r) == rangeLen:
		rangeALH =  map(lambda x: x.strip(),r)
	    else:
		warnings.append([fileName,lines,"Skip: ",devName,"Illegal length of rangeAlh (Col: L): \'"+rangeAlhSevr+"\'"])
	    	raise ValueError
	else:  	    	    	    	    	    	# .. fake a NO_ALARM range
	    rangeALH = map(lambda x: "NO_ALARM",range(rangeLen))
    else:
	warnings.append([fileName,lines,"Skip: ",devName,"Illegal rangeEng (Col: J): \'"+rangeEng+"\'"])
    return (rangeENG,rangeRAW,rangeALH)

def createAnalogRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal,fileName,lines):
#    print "createAnalogRecord",rtype,devName,signal,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr
    fields.update(getDisplayLimits(rangeEng,egu,signal,lines))
    (limitParams,dtype) = createLimits(rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,devName+":"+signal,lines)
    fields.update(limitParams)
    epicsUtils.epicsTemplate(rtype,{'DEVN':devName},fields)
    
def createBiBoRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhSevr,signal,fileName,lines):
    (rangeENG,rangeRAW,rangeALH) = getBinaryAttributes(rangeEng,rangeRaw,fields,fileName,lines)

    # set name and severitie fields
    idx=0
    if rtype == 'bi':
	rtype = 'mbbi'	# no use of mbbiDirect so bits by longin and mbbi SHFT
	fields['DTYP'] = "Raw Soft Channel"
    	fields['NOBT'] = '1'
	for state in ["ZR", "ON"]:
	    if epicsUtils.hasIndex(rangeENG,idx) is False:
		break
            namStr = rangeENG[idx]
	    l = len(namStr)
	    if l > 19:
		d = namStr[0:19] +" | " + namStr[19:l]
		namStr = namStr[0:19]
		warnings.append([fileName,lines,"Truncate bi/bo string",devName,d])
	    fields[state+"ST"]=namStr
	    fields[state+"VL"]=idx
	    if epicsUtils.hasIndex(rangeALH,idx) is True:
		if rangeALH[idx] != '' and rangeALH[idx] != 'NO_ALARM':
		    fields[state+"SV"]=rangeALH[idx]
            idx += 1
    else:    	
	for state in ["Z", "O"]:
	    if epicsUtils.hasIndex(rangeENG,idx) is None:
		break
            namStr = rangeENG[idx]
	    l = len(namStr)
	    if l > 19:
		d = namStr[0:19] +" | " + namStr[19:l]
		namStr = namStr[0:19]
		warnings.append([fileName,lines,"Truncate bi/bo string",devName,d])
	    fields[state+"NAM"]=namStr
	    if epicsUtils.hasIndex(rangeALH,idx) is True:
		if rangeALH[idx] != '' and rangeALH[idx] != 'NO_ALARM':
		    fields[state+"SV"]=rangeALH[idx]
            idx += 1
    epicsUtils.epicsTemplate(rtype,{'DEVN':devName},fields)
    return alias_extra

    
def createMbbIoRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhSevr,signal,fileName,lines):
    (rangeENG,rangeRAW,rangeALH) = getBinaryAttributes(rangeEng,rangeRaw,fields,fileName,lines)
    tooLong = False

    pvName = devName+":"+signal
    if len(rangeENG) > 16 :
	warnings.append([fileName,lines,"Truncate mbb modes"+pvName+" "+str(len(rangeENG))+", max=16"])

    idx = 0
    for state in ["ZR","ON","TW","TH","FR","FV","SX","SV","EI","NI","TE","EL","TV","TT","FT","FF"]:
	if epicsUtils.hasIndex(rangeENG,idx) is True:
	    if len(rangeENG[idx]) > 15 :
		tooLong=True
	else:
	    break
        idx += 1

    if (tooLong == False) or (rtype == "mbbo") :
        dbRec = epicsUtils.epicsTemplate(rtype,{'DEVN':devName},fields)
        idx=0
        for state in ["ZR","ON","TW","TH","FR","FV","SX","SV","EI","NI","TE","EL","TV","TT","FT","FF"] :
            if epicsUtils.hasIndex(rangeENG,idx) is False:
		break   # rangeENG[index]

	    namStr = rangeENG[idx]
	    if len(namStr) > 15:
		d = namStr[0:15] +" | " + namStr[15:l]
		namStr = namStr[0:15]
		warnings.append([fileName,lines,"Truncate mbb string",pvName,d])
            dbRec.field[state+"ST"]=namStr
            dbRec.field[state+"VL"]=rangeRAW[idx]
	    if epicsUtils.hasIndex(rangeALH,idx) is True:
		dbRec.field[state+"SV"]=rangeALH[idx]

            idx +=1 
    else:   # mbbi with long string names: each string gets a stringout !
        fields['SNAME'] = fields['SNAME']+'Raw'
	dbRec = epicsUtils.epicsTemplate(rtype,{'DEVN':devName},fields)
        idx=0
        stringOuts = ""
        seq = epicsUtils.epicsTemplate('seq',{'DEVN':devName},{'SNAME':signal+"S1",
		'SELM':"Specified", 
		'SELL':pvName+"C1 CP NMS",
		'SDIS':fields['SDIS'],'DISS':fields['DISS']
		})
	seqNr=1
        for state in ["ZR","ON","TW","TH","FR","FV","SX","SV","EI","NI","TE","EL","TV","TT","FT","FF"]:
            if epicsUtils.hasIndex(rangeENG,idx) is False:
		  break
            #d = substr(rangeENG[idx],0, 15) ." | " .substr(rangeENG[idx],15, length(rangeENG[idx]) )
            #push @warnings, [fileName,lines,"Truncate mbb string",pvName,d] if ( length(rangeENG[idx]) > 15 )
            if idx == 9 :
        	seq2 = epicsUtils.epicsTemplate('seq',{'DEVN':devName},{'SNAME':signal+"S2",
		    	'SELM':"Specified", 
			'SELL':pvName+"C2 CP NMS",
			'SDIS':fields['SDIS'],'DISS':fields['DISS']
			})
		seqNr=2
	    if seqNr==1:
		seq.field["LNK"+str(idx+1)]   = pvName+"St"+str(idx)+".PROC PP NMS"
	    else:
		seq2.field["LNK"+str(idx%9+1)] =  pvName+"St"+str(idx)+".PROC PP NMS"
            if (epicsUtils.hasIndex(rangeRAW,idx) is True) and (rangeRAW[idx] != '0'):
		dbRec.field[state+"VL"] = rangeRAW[idx]
	    	if epicsUtils.hasIndex(rangeALH,idx) is True:
		    dbRec.field[state+"SV"] = rangeALH[idx]
            eng = rangeENG[idx]
	    l = len(eng)
	    if l > 39:
		d = eng[0:39]+" | "+ eng[40:l]
		eng = eng[0:39]
		warnings.append([fileName,lines,"Truncate mbb string",pvName,d])
            epicsUtils.epicsTemplate('stringout',{'DEVN':devName},{'SNAME':signal+"St"+str(idx),
        	    		    'VAL':eng,
        			    'OUT':pvName+" PP NMS",
				    'SDIS':fields['SDIS'],'DISS':fields['DISS']})
	    idx += 1

    	epicsUtils.epicsTemplate('calc',{'DEVN':devName},{'SNAME':signal+"C1",
        		      'CALC': "(A<9)?A+1:0",
        		      'INPA': pvName+"Raw CP NMS",
			      'SDIS':fields['SDIS'],'DISS':fields['DISS']})
        epicsUtils.epicsTemplate('calc', {'DEVN':devName},{'SNAME':signal+"C2",
        		      'CALC': "(A>=9)?A-8:0",
        		      'INPA': pvName+"Raw CP NMS",
			      'SDIS':fields['SDIS'],'DISS':fields['DISS']})
	epicsUtils.epicsTemplate('stringin', {'DEVN':devName},{'SNAME':signal,
        		      'DESC': DESC,
        		      'SIML': pvName+"Raw.SIMM NPP MS",
			      'SDIS':fields['SDIS'],'DISS':fields['DISS']})

#******************************* Main program *******************************

separator    =','
output_db    = None
output_panel = None
output_alh   = None
output_arch  = None
output_req   = None
install_path = "."
display_search_path = ".:.."
iocName  = None
devName  = '(DEVICE)'
opc_name     = None
usage        = " %prog [options]"
parser = OptionParser(usage=usage,
		 version="%%prog %s" % my_version,
    		 description="USAGE: csv2epicsDb [-h OPTIONS] <csv files ...>")
parser.add_option("-v","--verbose",
		 action="store_true", # default: None
		 help="print debug information", 
    		 )
parser.add_option("-p","--panel",
		 action="store_true",
		 help="create 'CreatePanel.pl' data for Items that define EPICS PanelName (col. T, )", 
    		 )
parser.add_option("-t","--separator", 
		 action="store",
    		 type="string",
		 help="column separator []", 
    		 )
parser.add_option("-d","--output_db", 
		 action="store",
    		 type="string",
		 help="db file name file ending determines the ouptut: '.db' or '.substitutions'",
    		 )
parser.add_option("-l","--output_alh", 
		 action="store_true",
		 help="create alarm handler config file for Items that define BESSY ALH Group (col. Q, )", 
    		 )
parser.add_option("-a","--output_arch", 
		 action="store",
    		 type="string",
		 help="archiver config file name for signals defined n Col. O", 
    		 )
parser.add_option("-r","--output_req", 
		 action="store",
    		 type="string",
		 help="autoSaveRestore request file name for signals defined in Col. P", 
    		 )
parser.add_option("-n","--devName", 
		 action="store",
    		 type="string",
		 help="device name [\(DEVICE)]", 
    		 )
parser.add_option("-m","--opc_name", 
		 action="store",
    		 type="string",
		 help="opc server name", 
    		 )
parser.add_option("-c","--can", 
		 action="store",
    		 type="string",
		 help="CAN port Nr., or 'opc' for OPC server access",
    		 )
parser.add_option("-i","--iocName", 
		 action="store",
    		 type="string",
		 help="IOC name ",
    		 )
parser.add_option("-f","--install_path",
		 action="store",
    		 type="string",
		 help="installation path for output files: .substitutions, .arch, .alh, panels. Default is './'", 
    		 )
parser.add_option("-s","--display_search_path",
		 action="store",
    		 type="string",
		 help="for panel generation only, search path for widget header/footer files '.:..'", 
    		 )

(options, args) = parser.parse_args()
canport = ""
if options.separator    is not None: separator    = options.separator
if options.can   	is not None: canport	  = options.can
if options.output_db	is not None: output_db    = options.output_db
if options.panel	is not None: output_panel = options.panel
if options.install_path	is not None: install_path = options.install_path
if options.display_search_path	is not None: display_search_path = options.display_search_path
if options.output_arch	is not None: output_arch  = options.output_arch
if options.output_req	is not None: output_req   = options.output_req
if options.iocName	is not None: iocName      = options.iocName
if options.opc_name	is not None: opc_name	  = options.opc_name

sdis=""# options.devName+":disable CPP NMS"
iocTag = None

if iocName is not None:
    try:
    	m = epicsUtils.matchRe(iocName,"^\w*IO(C[\w\d]+$)")
	iocTag = m[0]
    except TypeError:
	pass

EPICS_STR_LEN = 28   # warn: truncated DESCription fields
warnings = []	     # global for warnings in all functions, is printed at end or prog.

lines = None
table = []  	    # Debug information in verbose mode
db   = []	    # substitution file lines
arch = []	    # archive list
req = []	    # autoSaveRestore list
panelList = epicsUtils.Panels(install_path,display_search_path)

def joinItarch(): return "\n".join(arch)
def joinItreq():  return "\n".join(req)

if output_db is None:
    print "Missing option -d outFile.db"
    sys.exit()
else:
    output_doc = epicsUtils.substRe(output_db,"\.\w+$","Doc.txt")

if canport == 'opc':
    docList(["Device Name","BESSY Signalname","PLC Name","Bits","Description","Typ\n----+-----"])
else:
    docList(["Device Name","BESSY Signalname","CAN-Port","CAN-Id","CardNr","Channel / Bits","Description","Typ\n----+-----"])
docList.setTitle( str(epicsUtils.matchRe(output_db,"(?:.*/|)(.*)\.\w+$")[0])+" Devices" )

types = { "db"  : [output_db, None],
          "doc":  [output_doc,docList.printDoc],
          "arch": [output_arch,joinItarch],
          "req" : [output_req, joinItreq ]}
if epicsUtils.matchRe(output_db,".*\.db$") is not None:
    types['db'][1] = epicsUtils.epicsTemplate.printAllRecords
elif epicsUtils.matchRe(output_db,".*\.substitutions$") is not None:
    types['db'][1] = epicsUtils.epicsTemplate.printAllSubst
else:
    epicsUtils.die("unknown output format for file -d '"+output_db+"'")
debugInfo = {}

for argument in args:
    if not os.path.isfile(argument): epicsUtils.die("File doesn't exist: "+argument)

    print "   Reading data from "+argument

    try :
    	(fileName,fileExt) = epicsUtils.matchRe(argument,'.*\/(.*)\.(.*)') 
    except TypeError : 
    	epicsUtils.die("found no filename in: "+argument)

    try :
	IN_FILE = open(argument) 
    except IOError: 
    	epicsUtils.die("can't open input file: "+argument)
    
    lines = 0
    reader = csv.reader(IN_FILE, delimiter=separator, quotechar='"',quoting=csv.QUOTE_ALL)

    for device in reader:
   	try:
	    lines += 1
	    if lines <= 1: # is header
	    	continue

	    try: dev        = device[0].strip() # A  devicname
	    except IndexError: dev = ""
	    try: rtype      = device[1].strip() # B  record-, template type
	    except IndexError: rtype = ""
	    try: signal     = device[2].strip() # C  BESSY Signalname
	    except IndexError: signal = ""
	    if canport == 'opc':
		try: PLCLink    = device[3].strip() # D  CAN-Port / SPS Symbolname
		except IndexError: PLCLink = ""
		try: DBLink     = device[4].strip()  # E  CAN-Id / Siemens DataType
		except IndexError: DBLink = ""
		try: dataType   = device[5].strip()  # F  Card-Nr / Siemens Access rights
		except IndexError: dataType = ""
	    else:
		try: 
		    canport    = int(str(device[3]).strip()) # D  CAN-Port / SPS Symbolname
	    	except IndexError: pass
		except ValueError: 
		    if len(device[3]) != 0:
		    	epicsUtils.die("ERROR: illegal argument -can: '"+str(device[3])+"' assumed here to be empty or a can port number",lines)
		    				
		try: canId     = device[4].strip()  # E  CAN-Id / Siemens DataType
		except IndexError: DBLink = ""
		try: cardNr    = device[5].strip()  # F  Card-Nr / Siemens Access rights
		except IndexError: dataType = ""
	    try: chan       = device[6].strip()  # G  binary: Inputbits bi/bo: nr, mbbi/o start-stop: e.g. 5-7 -> SHFT=5, NOBT=3 
	    except IndexError: chan = ""
	    try: rangeRaw   = device[7].strip()  # H  Datenbereich Rohdaten binary: '2|15|33', ai: '0-65535'
	    except IndexError: rangeRaw = ""
	    try: rangeEng   = device[8].strip()  # I  Datenbereich ENG     binary Named:'True|False|Invalid', anlog:' 0-100'
	    except IndexError: rangeEng = ""
    	    try: egu        = device[9].strip()  # J  Engeneering unit 
	    except IndexError: egu = ""
	    egu = egu.decode("UTF-8").encode("ISO-8859-1")      # konversion to ISO for edm!
	    try: rangeAlhVal= device[10].strip() # K  BESSY Alarm-Werte     anlog: LOLO=-5|HIGH=12
	    except IndexError: rangeAlhVal = ""
            try: rangeAlhSevr=device[11].strip() # L  BESSY Alarm-Zustand   anlog, bi : 'NO_ALARM|MINOR|MAJOR|INVALID'
	    except IndexError: rangeAlhSevr = ""
	    try: DESC       = device[12].strip() # M  BESSY Description
	    except IndexError: DESC = ""
	    try: prec       = device[13].strip() # N  BESSY Prec
	    except IndexError: prec = ""
	    try: archPeriod = device[14].strip() # O  BESSY Arch
	    except IndexError: archPeriod = ""
	    try: reqFlag    = device[15].strip() # P  BESSY SR
	    except IndexError: reqFlag = ""
	    try: alhGroup   = device[16].strip() # Q  BESSY ALH Group
	    except IndexError: alhGroup = ""
	    try: alhFlagsFlag=device[17].strip() # R  BESSY ALH Flags
	    except IndexError: snapFlag = ""
	    try: alhSort    = device[18].strip() # S  BESSY ALH Sort
	    except IndexError: alhSort = ""
	    try: panelName  = device[19].strip() # T  BESSY Panel name extended to panel Name: <panel>.edl
	    except IndexError: panelName = ""
	    try: panelGroup = device[20].strip() # U  BESSY Panel Group
	    except IndexError: panelGroup = ""
    	    try: panelSort  = device[21].strip() # V BESSY Panel Sort
	    except IndexError: panelSort = ""
	    alhFlags=''

    	    if len(dev)>0:  	# override -n option
	    	devName = dev
	    else: 
		devName = options.devName

	    if len(rtype) == 0: # is empty 
		continue
	    
	    ## Check if Description exceeds the EPICS String length, truncate it and create warning
	    if len(DESC) > EPICS_STR_LEN :
		lastIdx = EPICS_STR_LEN
		descTrunc = DESC[0:lastIdx]
		warnings.append([fileName,lines,"Truncate DESC",devName,descTrunc+" | "+DESC])
    		DESC = descTrunc
	    alias_extra = ""
	    alhSignals = []	    # templates may have a list of signals for alarm handler
	    arcSignals = []	    # templates may have a list of signals for archiver
    	    panelDict = {}  	    # panel widget macro data
	    panelNameDict = {}	    # panel widget PV name in form of {'TAG':pvName} dictionary
	    panelWidgetName = None

	    fields = {}
	    fields.update(epicsUtils.parseParam(prec))
    	    if len(signal) > 0: 	    	# is a record
		alhSignals.append(signal)
		arcSignals.append(signal)
		fields.update({'SNAME': signal,
	    		'DISS': 'INVALID',
	    		'SDIS': sdis,
    	    		'DESC': DESC})
		
		if canport == 'opc':
		    fields.update(epicsUtils.getOpcLink(PLCLink,rtype,chan,devName,lines,fileName))
    	    	else:	# ommit parameter or canport number means CAN link
    	    	    fields.update(epicsUtils.getHwLink(rtype,canport,canId,cardNr,chan,devName,fileName,iocTag,lines) )
		try:
    		    if rtype in ('ai','ao') :
	    		fields.update(getDisplayLimits(rangeEng,egu,signal,lines))
	    		createAnalogRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal,fileName,lines)
    		    elif rtype in ('longin','longout') :
	    		fields.update(getDisplayLimits(rangeEng,egu,signal,lines))
	    		fields['SNAME']=signal
	    		createAnalogRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal,fileName,lines)
		    elif rtype in ('bi','bo'):
			    createBiBoRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhSevr,signal,fileName,lines)
		    elif rtype in ('mbbi','mbbo'):
    	    		    createMbbIoRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhSevr,signal,fileName,lines)
    	    	    else:
			epicsUtils.epicsTemplate(rtype, {'DEVN':devName}, fields)
#			warnings.append([fileName,lines,"Skip unknown record type",devName,rtype])
		    if len(reqFlag) > 0: req.append(devName+":"+signal)

    		    if rtype in ('bo') :
			panelDict.update({'SNAME':signal,'EGU':egu,'DESC':DESC})
			panelWidgetName = "bo"
    		    elif rtype in ('ao','longout') :
			panelDict.update({'SNAME':signal,'EGU':egu,'DESC':DESC})
			panelWidgetName = "ao"
    		    elif rtype in ('mbbo') :
			panelDict.update({'SNAME':signal,'EGU':egu,'DESC':DESC})
			panelWidgetName = "mbbo"
		    else:
			panelDict.update({'SNAME':signal,'EGU':egu,'DESC':DESC})
			panelWidgetName = "anyVal"
		    panelNameDict.update({'DEVN':devName})
		except ValueError:
		    continue
	    else:	    	    	    	# is a template
		if len(reqFlag) > 0: 
	    	    req += map(lambda x: devName+":"+x,reqFlag.split("|"))

		if rtype=="aiFB":
    	    	    fields.update({'INP' : '@'+PLCLink})
		    alhSignals.append(devName+":set"+fields['TAG'])
		    arcSignals.append("set"+fields['TAG'])
		    panelNameDict.update({'DEVN':devName})
		    panelDict.update({'TAG':fields['TAG'],'DESC':DESC})
		    panelWidgetName = "aiFB"
		    createAnalogRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal,fileName,lines)
		elif rtype=="longinFB":
    	    	    fields.update({'INP' : '@'+PLCLink})
    	    	    fields.update(epicsUtils.parseParam(rangeAlhVal))
		    alhSignals.append(devName+":cmd"+fields['TAG'])
		    arcSignals.append("cmd"+fields['TAG'])
		    panelNameDict.update({'DEVN':devName})
		    panelDict.update({'TAG':fields['TAG'],'DESC':DESC})
		    panelWidgetName = "aiFB"
		    createAnalogRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal,fileName,lines)
		elif rtype=="biFB":
		    fld = epicsUtils.getOpcLink(PLCLink,'bi',chan,devName,lines,fileName)
		    fields.update(fld)
    	    	    fields.update(epicsUtils.parseParam(rangeAlhVal))
		    alhSignals.append(devName+":cmd"+fields['TAG'])
		    arcSignals.append("cmd"+fields['TAG'])
		    panelNameDict.update({'DEVN':devName})
		    panelDict.update({'TAG':fields['TAG'],'DESC':DESC})
		    panelWidgetName = "biFB"
		    createBiBoRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhSevr,signal,fileName,lines)
		elif rtype=="mbbiFB":
		    fld=epicsUtils.getOpcLink(PLCLink,'mbbi',chan,devName,lines,fileName)
		    fields.update(fld)
    	    	    fields.update(epicsUtils.parseParam(rangeAlhVal))
		    alhSignals.append(devName+":cmd"+fields['TAG'])
		    arcSignals.append("cmd"+fields['TAG'])
		    panelNameDict.update({'DEVN':devName})
		    panelDict.update({'TAG':fields['TAG'],'DESC':DESC})
		    panelWidgetName = "biFB"
		    createBiBoRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhSevr,signal,fileName,lines)
		elif rtype=="vacuum_OPC":
    	    	    fields.update({'DESC':DESC, 'INP':'@'+PLCLink,'EGU':egu})
    	    	    fields.update(epicsUtils.parseParam(rangeAlhVal))
		    alhSignals.append(devName+":lvac")
		    arcSignals.append(fields['TAG']+":lvac")
		    arcSignals.append(fields['TAG']+":vac")
		    panelDict.update({'TAG':fields['TAG'],'DESC':DESC,'EGU':egu})
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = "vmi"
		    epicsUtils.epicsTemplate(rtype, {'DEVN':devName}, fields)
    		elif epicsUtils.matchRe(rtype,"^vacuum_\w\w\w\d\d\d$") is not None:
		    (canOut,canIn,mux) = epicsUtils.adaCanMux(canId,cardNr,chan)
		    alhSignals.append("rdPress")
		    arcSignals.append("rdPress")
		    panelNameDict.update({'NAME':devName})
		    panelWidgetName = "Vmi"
		    epicsUtils.epicsTemplate(rtype, {'NAME':devName}, {
        		'DESC': DESC,
        		'CANPORT':canport,
			'OUTCAN': canOut,
			'INCAN':  canIn,
			'MUX':    mux,
			'ASG':    "",
			'SDIS':   "",})
		elif rtype=="vacuum_VarianDualController":
		    alhSignals.append("rdHighVolt")
		    alhSignals.append("rdPress")
		    arcSignals.append("rdHighVolt")
		    arcSignals.append("rdPress")
		    panelNameDict.update({'NAME':devName})
		    panelWidgetName = "Gpps"
		    (canOut,canIn,mux) = epicsUtils.adaCanMux(canId,cardNr,chan)
		    mux1 = "%X"% (int(cardNr)*12+1+int(chan),)
		    epicsUtils.epicsTemplate(rtype, {'NAME':devName}, {
        		'DESC': DESC,
        		'CANPORT':canport,
			'OUTCAN': canOut,
			'INCAN':  canIn,
			'MUX':    mux,
			'MUX2':   mux1,
			'ASG':    "",
			'SDIS':   "",})
    		elif rtype=="valve_VCTRL":
		    alhSignals.append("stItlHw",)
		    arcSignals.append("stModOpen",)
		    arcSignals.append("stItlHw",)
		    panelNameDict.update({'NAME':devName})
		    panelWidgetName = "Valve"
		    canOut = "%X"%(576+int(canId),)
		    canIn  = "%X"%(512+int(canId),)
		    muxIn  = "%X"%(int(cardNr)*2,)
		    muxOut = "%X"%(int(cardNr)*2+1,)
		    epicsUtils.epicsTemplate(rtype, {'NAME':devName}, {
        		'DESC': DESC,
        		'CANPORT':canport,
			'OUTCAN': canOut,
			'INCAN':  canIn,
			'MUXIN':  muxIn,
			'MUXOUT': muxOut,
			'ASG':    "",
			'ASGOPEN':    "OPEN",
			'SDIS':   "",})
		elif rtype=="aiCAN":
	    	    fields.update({'DISS': 'INVALID',
        	    	    'INP':  epicsUtils.createAdaCanLink(canport,canId,cardNr,chan),
    	    	    	    'DESC': DESC})
		    alhSignals.append("rdVolt")
		    arcSignals.append("rdVolt")
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = "aiCAN"
		    createAnalogRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal,fileName,lines)
		elif rtype=="pmu":
	    	    createLimits(rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,devName,None)
		    fields['RANGE'] = rangeEng+" "+egu
		    fields.update({'DISS': 'INVALID',
        	    	    'INP':  epicsUtils.createAdaCanLink(canport,canId,cardNr,chan),
    	    	    	    'DESC': DESC})
		    alhSignals.append("rdPwr")
		    arcSignals.append("rdPwr")
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = "PMU"
		    createAnalogRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal,fileName,lines)
    		elif rtype=="pt100temp":
		    alhSignals.append("rdTemp")
		    arcSignals.append("rdTemp")
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = "temp"
		    try:
    	    		hwname = epicsUtils.getEcName(canport,canId,cardNr,iocTag)
    	    	    except ValueError:
    	    		epicsUtils.die("ERROR: "+devName+" CAN definition Port=\'"+canport+"\' Id: \'"+canId+"\' Card: \'"+cardNr+"\''",lines)

		    if epicsUtils.epicsTemplate.getDevice(hwname) is None:
			(co,ci,mux) = epicsUtils.adaCanMux(canId,cardNr,0,'dec')
			mux=int(cardNr)*12

			epicsUtils.epicsTemplate("pt100dev",{'DEVN':hwname},{
		    	    'CANPORT': canport,
			    '0XSINOBJ':"%X"%(128+int(canId)),
			    '0XSOUTOBJ':"%X"%(192+int(canId)),
			    '0XSMUX':"%X"%(int(cardNr)*4+17),
			    'INOBJ':ci,
			    'OUTOBJ':co,
			    'C0MUX':mux,
			    'C1MUX':mux+1,
			    'C2MUX':mux+2,
			    'C3MUX':mux+3,
			    'C4MUX':mux+4,
			    'C5MUX':mux+5,
			    'C6MUX':mux+6,
			    'C7MUX':mux+7
			    })
		    if egu == "K":	    # template default is Grad-C
			fields['EGUF'] = "657.16"
			fields['EGUL'] = "145.16"
			fields['EGU'] = "K"
		    fields['DESCR'] = DESC
		    fields['SDIS']  = ""
		    fields['HWNAME']= hwname
    	    	    chan = int(chan)
		    if chan<8: 
			ch  = 1
			sub = chan
		    else:      
			ch  = 2
			sub = chan-8
		    statnr = "%X"%(chan)
		    fields['CHAN']  = ch
		    fields['STATNR']= statnr
		    fields['SUB']   = sub
		    createAnalogRecord(rtype,devName,fields,rangeEng,rangeRaw,rangeAlhVal,rangeAlhSevr,signal,fileName,lines)
    		elif rtype=="foilMonitor":
		    alhSignals.append("stPos")
		    arcSignals.append("stPos")
		    panelNameDict.update({'DEVN':devName})
		    panelWidgetName = None
		    ch = chan.split("|")
		    if int(ch[0])+1 != int(ch[1]):
	    		warnings.append([fileName,lines,"WARN: ",devName,"No consecutive input parameters: "+chan+", assumed: "+str(ch[0])+"|"+str(int(ch[0])+1)])
    	    	    epicsUtils.epicsTemplate("foilMonitor",{'DEVN':devName},{
			'CARD': cardNr,
			'CHAN': ch[0],
			'DTYP': canId
			})
		else:
		    print "Skip unsupported record/template '"+rtype+"' Line:",lines
		    continue
    	    # END search and create record type
	    # now processing is done, an record is created and we can use the variables, set 
	    # for this line of the spread sheet to do some optional stuff
    	    if canport == 'opc':
	    	docList([devName,device[2],device[3],device[6],device[12],device[1]])
	    else:
	    	docList([device[0],device[2],device[3],device[4],device[5],device[6],device[12],device[1]])
	    if options.verbose is True:
		rangeRawCut = rangeRaw
		if len(rangeRaw)> 23:
		      rangeRawCut = rangeRaw[0:20] +"..."
		rangeEngCut = rangeEng
		if len(rangeEng)> 23:
		      rangeEngCut = rangeEng[0:20] +"..."
		table.append([fileName,lines,rtype,devName,link,rangeEngCut,rangeRawCut,egu,DESC])

	    if output_panel is not None and len(panelName)>0: # for panel creation
#    		print "panelList.addItem(",panelName,panelGroup,panelNameDict,panelDict,panelWidgetName,panelSort+")"
		panelList.addItem(panelName,panelGroup,panelNameDict,panelDict,panelWidgetName,panelSort)

	    if archPeriod is not None and len(archPeriod)>0:
		for signal in arcSignals:
	    	    arch.append( "<channel><name>"+devName+":"+signal+"</name><period>"+archPeriod+"</period><monitor/></channel>")

	    if alhGroup is not None and len(alhGroup)>0:
		for alhSig in alhSignals:
    		    epicsUtils.epicsAlh(devName,alhSig,alhGroup,alhFlags,panelName,alhSort,lines)
    	except :
	    print "Parse exception in line:",lines
	    raise
    IN_FILE.close()
    # end for
#########################################################################
    epicsUtils.X_Address.setupTemplates(devName,'opc')
  # Create files
    for typ in types.keys():
      	outfile = types[typ][0]
      	strOut  = types[typ][1]()
	if outfile == None or len(strOut) == 0:
            continue
      	else:
	    try:
	    	outFileName = install_path+"/"+outfile
		OUT_FILE = open(outFileName,"w") 
	    except IOError: 
	    	epicsUtils.die("can't open output file: "+outFileName)
	print "   Creating file "+outFileName
      	#print "*****************************\n", strOut
	print >> OUT_FILE, strOut
	OUT_FILE.close()

    if options.output_alh is True:
	epicsUtils.epicsAlh.printFiles(install_path)
    	
    if options.verbose is True:
	epicsUtils.printTable(table,["file","line","record","devName","link","rangeEng","rangeRaw","EGU","DESC"],1 ) 

  #  str  map { str += "\t_\tsoftLinkTag{_}\n" } keys(%softLinkTag) print "mbbiDiret Ids:\nstr\n"
    if (output_db is not None) and (len(warnings) > 0):
      	print "\nWARNINGS\n********\n\n"
      	epicsUtils.printTable(warnings, ["file","line","Warning","PV-Name","Value"])
      	print "\n"

    if output_panel is not None:  # for panel creation panelInfos->{recordType}->[pv1, pv2...
	panelList.printAll()
