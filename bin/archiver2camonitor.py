#! /usr/bin/env python
# -*- coding: UTF-8 -*- 
"""
======================
 archiver2camonitor.py
======================
------------------------------------------------------------------------------
 a tool to convert channel access "plot" data to a camonitor compatible format
------------------------------------------------------------------------------

Overview
===============
Using the channel access archiver to retrieve values
for many process variables is problematic. The "plot"
cannot be used when the number of PVs is greater than
about 5. In "spreadsheet" format, a table with more than
about 20 columns is also almost unusable. The only solution
is to generate a plot, the click on the plot to get the
values in text form, one value below the next. However, this
format displays dates in US format which is difficult to sort
and it prints all values sorted by PV name, the PV name mentioned
first followed by a list of values with timestamps. Here is an
example::

  # Generated by ArchiveExport 2.9.2
  # Method: Plot-Binning, 21 sec bins
  # Channel 'UE52ID5R:AmsTempT1'
  01/21/2008 16:00:00.000000000   27.4299966      
  01/21/2008 16:00:21.893549387   27.3488406   

  # Channel 'UE52ID5R:AmsTempT2'
  01/21/2008 16:00:00.000000000   27.1865286      
  01/21/2008 16:01:08.891708519   27.1053725  

Much better would be the camonitor format which looks 
like this::

  UE52ID5R:BasePmGap.D           2008-01-21 18:13:09.212615220 99.5837 
  UE52ID5R:BasePmP.A             2008-01-21 18:13:09.212615220 582921 
  UE52ID5R:BasePmP.C             2008-01-21 18:13:09.212615220 582921 
  UE52ID5R:BasePmP.D             2008-01-21 18:13:09.212615220 582918 
  UE52ID5R:CIOC:rdbk0            2008-01-21 18:13:09.773965819 99.2451811 

This tool converts data from the first format to the second. 

Quick reference
===============

* convert a file and print to standard-out::

    archiver2camonitor.py -f myfile

* read from standard-in and print to standard-out::

    archiver2camonitor.py < myfile

Reference of command line options
=================================

--summary
  print a one-line summary of the scripts function

-f FILE, --file FILE
  specify the file to read from. If this option is missing, all
  left-over arguments on the command line are interpreted as filenames.
  If this option is missing and there are no left-over arguments on the
  command line, the program reads from standard-in. If more than one
  file is given, the sorting of the results in done across the sum
  of all files 

-t, --test
  perform a self-test for some functions (used only for debugging the script)

--doc
  print reStructuredText documentation (THIS text :-)...). Use
  "./archiver2camonitor.py --doc | rst2html" to create a html documentation.

"""
from optparse import OptionParser
#import string
import sys
import os.path

import re

from FilterFile import *

# version of the program:
my_version= "1.0"

# regular expression strings:
rx_str_float= r'[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?'

rx_str_float_or_word= r'(' + rx_str_float + r'|\S+)'

rx_str_us_date= r'(\d+/\d+/\d{4})'

rx_str_time= r'(\d+:\d+:\d+\.?\d*)'

rx_str_quoted= r"'([^']+)'"

# regular expression objects:
rx_channel= re.compile(r"^\s*#\s*Channel\s+'([^']+)'\s*$")

rx_data= re.compile("".join((r'^',rx_str_us_date,r'\s+',
                             rx_str_time,r'\s+',rx_str_float_or_word,
			     r'\s*(.*)$')))

rx_disconnect= re.compile("".join((r'^# ',rx_str_us_date,r'\s+',
                          rx_str_time,r" Disconnected\s*$")))

rx_comment= re.compile(r'^\s*#')

def empty(string):
    r"""returns True when the string is empty or just spaces

    Here are some examples:
    >>> empty("")
    True
    >>> empty(" ")
    True
    >>> empty(" \n")
    True
    >>> empty(" \nx")
    False
    """
    if len(string)==0:
        return True
    return string.isspace()

def usdate2iso(date):
    """converts an US-Date to ISO format.
    
    Here is an example:
    >>> usdate2iso('01/21/2008')
    '2008-01-21'
    """
    elms= date.split('/')
    return "%4d-%02d-%02d" % (int(elms[2]),int(elms[0]),int(elms[1]))

def is_comment(line):
    """returns True if the line is a comment line.

    Here are some examples:
    >>> is_comment(r'ldkfj')
    False
    >>> is_comment(r'#ldkfj')
    True
    >>> is_comment(r'  #ldkfj')
    True
    """
    return re.match(rx_comment,line) is not None

def is_channel(line):
    """returns the channel if one can be matched.
    
    examples of a valid channel definition:
    # Channel 'UE52ID5R:version'
    
    Here are some examples for the function:
    >>> is_channel(r"# Channel 'UE52ID5R:version'")
    'UE52ID5R:version'
    >>> is_channel(r"# Channel")
    """
    m= re.match(rx_channel,line)
    if m is None:
        return None
    return m.group(1)

def is_disconnected(line):
    """returns date and time of a "disconnect" message.

    example of a disconnect message:
    # 02/21/2008 13:28:30.309669580 Disconnected
    
    Here are some examples for the function:
    >>> is_disconnected(r"# 02/21/2008 13:28:30.309669580 Disconnected")
    ('02/21/2008', '13:28:30.309669580', 'Disconnected', '')

    If nothing is matched, the function returns None:
    >>> print is_disconnected(r'01/21/2008 18:45:00.000000000   62.0872102')   
    None
    """
    m= re.match(rx_disconnect,line)
    if m is None:
        return None
    return(m.group(1),m.group(2),"Disconnected","")
    

def is_data(line):
    """scans a data line.
    
    returns:
    a tuple with date,time,value,extra-string
     -or-
    None if string couldn't be matched
    
    example:
    01/21/2008 18:45:00.000000000   62.0872102 INVALID TIMEOUT

    Here are some examples for the function:
    
    Timestamp with value:
    >>> is_data(r'01/21/2008 18:45:00.000000000   62.0872102')
    ('01/21/2008', '18:45:00.000000000', '62.0872102', '')
    
    Timestamp with value and extra flags:
    >>> is_data(r'01/21/2008 18:45:00.000000000   62.0872102 INVALID TIMEOUT')
    ('01/21/2008', '18:45:00.000000000', '62.0872102', 'INVALID TIMEOUT')
    
    The value can also be a string:
    >>> is_data(r'01/21/2008 18:45:00.000000000   enabled')
    ('01/21/2008', '18:45:00.000000000', 'enabled', '')

    Value is missing, the function returns None:
    >>> print is_data(r'01/21/2008 18:45:00.000000000 ')
    None
    """
    m= re.match(rx_data,line)
    if m is None:
        return None
    return(m.group(1),m.group(2),m.group(3),m.group(4))

def process_iterable(iterable,results,from_msg=""):
    r"""process lines from an iterable.
    
    parameters:
    iterable   -- an iterable type of strings
    results    -- the results are stored in this dictionary
    from_msg   -- used for the error message. Typically
    	          a string like "in file xy "
    
    Here is an example how process_iterable() scans lines
    as they come typically from the channel access 
    archiver. 
    >>> results={}
    >>> process_iterable('''
    ... # Generated by ArchiveExport 2.9.2
    ... # Method: Plot-Binning, 21 sec bins
    ... # Channel 'UE52ID5R:AmsTempT1'
    ... 01/21/2008 16:00:00.000000000   27.4299966      
    ... 01/21/2008 16:00:21.893549387   27.3488406   
    ... 
    ... # Channel 'UE52ID5R:AmsTempT2'
    ... 01/21/2008 16:00:00.000000000   27.1865286      
    ... 01/21/2008 16:01:08.891708519   27.1053725  
    ... '''.split("\n"),results)

    After process_iterable() was executed, the results dictionary
    contains keys consisting of the date, the time and the pv
    that map to strings in camonitor format: 
    >>> for key in results.keys():
    ...     print key,"->\n       ",results[key]
    ... 
    2008-01-21 16:00:00.000000000 UE52ID5R:AmsTempT1 ->
            UE52ID5R:AmsTempT1             2008-01-21 16:00:00.000000000 27.4299966
    2008-01-21 16:01:08.891708519 UE52ID5R:AmsTempT2 ->
            UE52ID5R:AmsTempT2             2008-01-21 16:01:08.891708519 27.1053725
    2008-01-21 16:00:00.000000000 UE52ID5R:AmsTempT2 ->
            UE52ID5R:AmsTempT2             2008-01-21 16:00:00.000000000 27.1865286
    2008-01-21 16:00:21.893549387 UE52ID5R:AmsTempT1 ->
            UE52ID5R:AmsTempT1             2008-01-21 16:00:21.893549387 27.3488406

    Here we see how two consecutive calls to process_iterable()
    gather data in the results dictionary:
    >>> results={}
    >>> process_iterable(["# Channel 'UE52ID5R:AmsTempT1'",
    ...                   "01/21/2008 16:00:00.000000000   27.4299966"],results)
    >>> process_iterable(["# Channel 'UE52ID5R:AmsTempT1'",
    ...                   "01/21/2008 16:00:21.893549387   27.3488406"],results)

    The results dictionary contains both lines:
    >>> for key in results.keys():
    ...     print key,"->\n       ",results[key]
    ... 
    2008-01-21 16:00:00.000000000 UE52ID5R:AmsTempT1 ->
            UE52ID5R:AmsTempT1             2008-01-21 16:00:00.000000000 27.4299966
    2008-01-21 16:00:21.893549387 UE52ID5R:AmsTempT1 ->
            UE52ID5R:AmsTempT1             2008-01-21 16:00:21.893549387 27.3488406
    
    An invalid line raises an exception:
    >>> results={}
    >>> process_iterable(["ldfjsldfj"], results,"in teststring ")    
    Traceback (most recent call last):
       ...
    AssertionError: parse error in teststring line 1
    """
    channel= None
    lineno=0
    for line in iterable:
        lineno+=1
	if empty(line):
	    continue
	tp= None
	if is_comment(line):
	    # may be a comment or a channel definition or
	    # a disconnect message
	    st= is_channel(line)
	    if st is not None:
	        channel= st
		continue
	    tp= is_disconnected(line) # returns date, time, "Disconnected"
	    if tp is None:
	        continue # ignore all other comments
	if tp is None:   # if tp is none, try to read data
	    tp= is_data(line)
	if tp is None:
	    print "LINE:",line
	    raise AssertionError,"parse error %sline %d" % (from_msg,lineno)      
	if channel is None:
	    raise AssertionError,"unknown channel"
	date= usdate2iso(tp[0])
	if not empty(tp[3]): # extra flags present
	    extra= " " + tp[3]
	else:
	    extra= ""
	key= " ".join((date,tp[1],channel)) 
	results[key]= "%-30s %s %s %s%s" % \
	              (channel,date,tp[1],tp[2],extra)
	continue	     


def process(filename_,results):
    """process input from standard-in or from a file."""
    in_file= FilterFile(filename=filename_,opennow=True)
    process_iterable(in_file.fh(),results,"in file %s " % filename_)
    in_file.close()
    
def process_files(options,args):
    """process all files given on the command line.
    
    parameters:
      options    --  this may contain a "file" member with
      		     the filename
      args       --  this may be a list of strings containing
      		     extra filenames
    output:
      prints the sorted values to standard-out
    """
    filelist= []
    if (options.file is not None):
        filelist=[options.file]
    if len(args)>0: # extra arguments
        filelist.extend(args)
    if len(filelist)<=0:
        filelist= [None]
    results= {}
    for f in filelist:
        process(f,results)
    keys= sorted(results.keys())
    for k in keys:
        print results[k]   

def script_shortname():
    """return the name of this script without a path component."""
    return os.path.basename(sys.argv[0])
	  
def print_summary():
    """print a short summary of the scripts function."""
    print "%-20s: convert archiver data format to camonitor format\n" % script_shortname()

def print_doc():
    """print embedded reStructuredText documentation."""
    print __doc__

def _test():
    """does a self-test of some functions defined here."""
    print "performing self test..."
    import doctest
    doctest.testmod()
    print "done!"

def main():
    """The main function.
    
    parse the command-line options and perform the command
    """
    
    # command-line options and command-line help:
    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage,
                	  version="%%prog %s" % my_version,
			  description="convert archiver data format to camonitor format")
    parser.add_option("--summary",  # implies dest="nodelete"
                      action="store_true", # default: None
                      help="print a summary of the function of the program", 
		      )

    parser.add_option("-t", "--test",     # implies dest="switch"
                      action="store_true", # default: None
                      help="perform simple self-test", 
		      )

    parser.add_option("-f", "--file", # implies dest="file"
                      action="store", # OptionParser's default
		      type="string",  # OptionParser's default
                      help="specify the FILE", 
		      metavar="FILE"  # for help-generation text
		      )
    parser.add_option( "--doc",            # implies dest="switch"
                      action="store_true", # default: None
                      help="create online help in restructured text"
                           "format. Use \"./txtcleanup.py --doc | rst2html\" "
                           "to create html-help"
                      )

    (options, args) = parser.parse_args()
    # options: the options-object
    # args: list of left-over args

    if options.summary:
        print_summary()
	sys.exit(0)

    if options.doc:
        print_doc()
        sys.exit(0)

    if options.test:
        _test()
	sys.exit(0)
	
    process_files(options,args)
    sys.exit(0)

if __name__ == "__main__":
    #print __doc__
    main()

